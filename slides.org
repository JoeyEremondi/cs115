#+title: University of Regina, CS 115, Winter 2025
#+subtitle: CS 115
#+AUTHOR: Dr. Joseph Eremondi, adapted from Dr. Shakil Khan, Dr. Philip Fong, and Dr. Howard Hamilton
#+DATE: Last updated: \today{}



#+OPTIONS: toc:nil H:2 TODO:nil eval:yes

#+BEAMER_HEADER: \usepackage[sfdefault]{atkinson} %% Option 'sfdefault' if the base
#+BEAMER_HEADER: \usepackage{FiraMono}
#+BEAMER_HEADER: \usepackage[T1]{fontenc}




#+EXPORT_FILE_NAME: pdf/slides_all.pdf
#+startup: beamer
#+LaTeX_CLASS:beamer
#+BEAMER_CLASS_OPTIONS: [bigger, aspectratio=169, dvipsnames]
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col)
#+beamer: \beamerdefaultoverlayspecification{<+->}


# -*- org-latex-packages-alist: nil; -*-

# #+BEAMER_HEADER: \renewcommand{\pageword}{}


# #+BEAMER_HEADER: \usetheme[customfont,nofooter]{pureminimalistic}
#+BEAMER_HEADER: \usetheme{moloch}
# #+BEAMER_HEADER:\definecolor{textcolor}{RGB}{0, 0, 0}
#+BEAMER_HEADER:\definecolor{title}{RGB}{2, 71, 49}
# #+BEAMER_HEADER:\renewcommand{\beamertextcolor}{textcolor}
# #+BEAMER_HEADER:\renewcommand{\beamerfootertextcolor}{footercolor}
# #+BEAMER_HEADER:\renewcommand{\beamertitlecolor}{title}
# #+BEAMER_HEADER:\setbeamertemplate{frametitle}{\\setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamercolor{alerted text}{fg=black}
#+BEAMER_HEADER: \setbeamerfont{alerted text}{series=\bfseries}
#+BEAMER_HEADER: \newcommand{\colored}[2]{{\color{#1} #2}}


#+LATEX_HEADER: \newcommand{\colored}[2]{{\color{#1} #2}}


#+BEAMER_HEADER: \usepackage[utf8]{inputenc}
#+BEAMER_HEADER: \usepackage[libertine]{newtxmath}
#+BEAMER_HEADER: \usepackage{semantic}
#+BEAMER_HEADER: \usepackage{stmaryrd}
#+BEAMER_HEADER: \mathlig{=>}{\Rightarrow}
#+BEAMER_HEADER: \definecolor{LightGray}{gray}{0.9}
#+BEAMER_HEADER: \usepackage[outputdir=pdf]{minted}
#+BEAMER_HEADER: \usepackage{etoolbox}
#+BEAMER_HEADER: \usepackage{hyphenat}
#+BEAMER_HEADER: \AtBeginEnvironment{minted}{\pause}
#+BEAMER_HEADER: \setminted[racket]{escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}
#+BEAMER_HEADER: \setminted[c++]{autogobble,escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}
#+BEAMER_HEADER: \setminted[C++]{autogobble,escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}


#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[libertine]{newtxmath}
#+LATEX_HEADER: \usepackage{semantic}
#+LATEX_HEADER: \usepackage{stmaryrd}
#+LATEX_HEADER: \mathlig{=>}{\Rightarrow}
# #+LATEX_HEADER: \definecolor{LightGray}{gray}{0.9}
#+LATEX_HEADER: \usepackage[outputdir=pdf]{minted}
#+LATEX_HEADER: \usepackage{etoolbox}
#+LATEX_HEADER: \usepackage{hyphenat}
# #+LATEX_HEADER: \AtBeginEnvironment{minted}{\pause}
# #+LATEX_HEADER: \setminted[racket]{escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}
# #+LATEX_HEADER: \setminted[C++]{autogobble,escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}
# #+LATEX_HEADER: \setminted[C++]{autogobble,escapeinside=||,bgcolor=LightGray,beameroverlays=true,baselinestretch=1.2,fontsize=\scriptsize}

#+PROPERTY: header-args:C++  :includes <iostream> :prologue "using namespace std;"

* Contents :TOC_1_gh:
- [[#introduction][Introduction]]
- [[#review][Review]]
- [[#arrays][Arrays]]
- [[#records][Records]]
- [[#program-organization-principles][Program Organization Principles]]
- [[#abstract-data-types-via-classes][Abstract Data Types via Classes]]
- [[#searching-and-sorting][Searching and sorting]]
- [[#constructors-and-overloading][Constructors and overloading]]
- [[#review-types-and-values][Review: Types and Values]]
- [[#object-oriented-design-composition-and-inheritance][Object-oriented design: Composition and Inheritance]]
- [[#object-oriented-design-interfaces-subtying-and-polymorphism][Object-oriented design: Interfaces, Subtying and Polymorphism]]
- [[#templates-and-generics][Templates and Generics]]
- [[#pointers][Pointers]]

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides000-intro.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

** Welcome to CS 115

*** What is this course all about?


**** Objectives
- Various concepts of object oriented programming. Topics include: two-dimensional arrays, records, data abstraction, classes, composition and inheritance, type systems, subtyping, dynamic binding, polymorphism, pointers/references, dynamic memory management, and searching and sorting algorithms. Along the way, we may also discuss software engineering concepts, including comprehensibility, correctness, efficiency, and refactoring.

*** What is this course all about?

**** Major theme: Types
- This course gives you your first real look at /types/ in programming
  + How to define your own types
  + How to use types to structure programs
- More than just ~int~ and ~bool~

*** What is this course all about?

**** Major theme: Software Engineering
- CS 110 is how to write code
- CS 115 is how to write *good* code
- i.e. How to write code that is easy to:
  + Understand
  + Maintain
  + Re-use
  + Extend
- /Intentionally limiting/ the ways we are allowed to use parts of our program
  +  Abstraction is at the heart of computer science
*** Tentative Outline
- Review
- 2D arrays, records (structs), abstract data types
- Searching and sorting
- Object Oriented Design
  + Classes and constructors
  + Overloading and coercion
  + Composition and inheritance
- Pointers and dynamic memory management
- Program organization

*** Learning Objectives
**** By the end of this course, you should be understand
  + Data abstraction, encapsulation, polymorphism
  + Solving real world problems with object-oriented principles
  + Using composite types and abstract types to solve real-world problems
  + Approaches to searching and sorting
  + C++ OOP features
    - Operator overloading, type coercions, constructors, destructors
  + Pointers, dynamic memory management, and linked data structures
  + Modular programming with inheritance and composition


*** Grading
- 20% assignments
- 15% labs
- 20% midterm
- 45% final
  + Must pass final to pass the class

*** Midterm
- In-class, Friday March 7
  + Might be split into two rooms

*** Labs
- See [[https://www.labs.cs.uregina.ca/115/]]

*** Assignments
- 4 Assignments
- Submitted on URCourses
- Sample based marking
  + You submit the whole thing, we mark part of it

*** Office Hours
- Tuesdays 11:00-12:00
- Thursdays 10:30-11:30
- In RIC 317
  + Take the elevator then go across the bridge
  + or, take the stairs by the vending machines

*** Course Communication
- In lectures
- Announcements on URCourses
- Course email on URCourses
  + For privately contacting instructor
  + Save for things that need to be private
    - Personal circumstances
    - Assignment solutions

*** Course Discussion Forum
- Ask questions on URCourses!
  + Can be asked anonymously
  + If you're wondering, then other students probably are too
  + Don't post partial or complete assignment solutions on the forum
- Good for
  + Clarification on assignments
  + Understanding course material
  + General curiosity/information beyond the lectures

*** Academic Honesty
**** Students are expected to complete assignments /independently/
- No sharing solutions
- No copying from the internet
- No using ChatGPT, Copilot, Claude, or any other Generative AI tool.
**** You need to pass the final, so set yourself up for success and do the assignments

*** Other Logistics
- Attendance expected
  + You're responsible for anything you miss
- There are detailed course notes on URCourses
  + by Howard Hamilton and Phillip Fong
  + Excellent *free* resource
- Lectures are a great time to *ask questions*

* Review
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides001-review.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

 
** Basic program structure, local/global variables, value passing semantics, strings, program dev. process
 
*** Hello world!
 

#+begin_src C++
#include <iostream>
using namespace std;

int main( ){
  cout << "Hello, World!" << endl;
  return 0;
}



#+end_src

 - 4 types of control structures: 
   + sequences (see above)
   + conditionals
   + loops
   + function invocations
 
*** Functional abstraction
 
**** Example :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
// Declaration of the triple function
int triple(int x);

int main( ){
  int answer;
  answer = triple(5);
  cout << answer << endl;
  cout << triple(2) << endl;
  return 0;
}

// Definition of the triple function
int triple(int x) {
  return 3 * x;
}
#+end_src

**** Declaration vs. Definition :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Must declare functions before referencing them
 - use function prototype /header
 - OR declare before 1st use
 
 - Scope of a function = file scope
 
 - Can a function call itself?!
 
*** Local and global variables and constants

**** Example :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
// Declaration of a global variable
int g;

// Declaration of a global constant
const int THREE = 3;

int main( ){
  const int LOC = 29;
  int loc = LOC;
  g = 42;
  cout << g << endl;
  tripleGlobal();
  cout << g << endl;
  return 0;
}
#+end_src

**** ctd. :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
void tripleGlobal( ){
  // The local var loc is not acc.
  // The global var g is accessible
  g = THREE * g;
}

#+end_src

 - Use ``extern'' to access global variables declared in other files

*** Conditionals (if-then-else branching)
 

#+begin_src C++
int max(int a, int b){
  if (a >= b)
    return a;
  else
    return b;
}



int main( ){
  cout << max(-1, 2) << endl;
  cout << max(1, -2) << endl;
  return 0;
}


#+end_src

*** Conditionals (ternary operator cond ? b1 : b2)
 
 - Compare the following:
 

 #+begin_src C++
int max(int a, int b){
  if (a >= b)
    return a;
  else
    return b;
}

int max(int a, int b) {
  return (a >= b) ? a : b;
}

 #+end_src



*** Conditionals (nesting)

 - Can be nested:


 #+begin_src C++
int inRange(int num, int low, int high) {
  if(num>=low)
    if(num<=high)
      return 1;
  return 0;
}

 #+end_src

 - Note: could have used a compound conditional statement instead

*** Conditionals (else-if and switch cases)
 
 - Can have multiple branches:
 

 #+begin_src C++
int sign(int a){
  if (a > 0)
    return 1;
  else if (a < 0)
    return -1;
  else
    return 0;
}



 #+end_src


*** Conditionals (else-if and switch cases)


 - Switch cases?
 #+begin_src C++
switch (month){
 case 1: case 2: case 3: case 4:
   cout << "Winter";
   break;
 case 5: case 6: case 7: case 8:
   cout << "Spring";
   break;
 case 9: case 10: case 11: case 12:
   cout << "Fall";
   break;
 default:
   cout << "Error, universe broken";
 }

 #+end_src

*** Repetition structures (loops)
 
 - Want to compute: 
 - f(n) = 1 + 2 + 3 + ... + n
 

 #+begin_src C++
unsigned int triangular(unsigned int n){
  unsigned int result = 0;
  for (unsigned int i = 1; i <= n; i++){
    result += i;
  }
  return result;
}

 #+end_src

 - Order of execution?
 
 - Can have an empty body!
 
 
 
*** Repetition structures (loops)
 

#+begin_src C++
const unsigned int BASE = 10;

unsigned int sumOfDigits(unsigned int m){
  unsigned int sum = 0;
  while (m != 0) {
    unsigned int digit;
    digit = m % BASE;
    sum = sum + digit;
    m = m / BASE;
  }
  return sum;
}
#+end_src

 - More explicit than for loops
 
 - Do-while: like while, but executes at least once
 
 - Loops can be nested
 
*** Value passing semantics
 
 - Call by value (arguments evaluated)
 

 #+begin_src C++
void doubleV(int a){
  a = a*2;
}

int main( ){
  int a = 2;
  doubleV(a+a);
  cout << a << endl;

  return 0;
}
 #+end_src

*** Value passing semantics

 - Call by reference (can only send vars)
 

 #+begin_src C++
void doubleR(int &a){
  a = a*2;
}

int main() {
  int a = 4;
  doubleR(a);
  cout << a << endl;

  return 0;
}
 #+end_src

*** Value passing semantics
 
 - Call by address (arguments evaluated)
   + We'll see more of this later
   + Have to explicitly get dereference
     - i.e. get value from the address
 

 #+begin_src C++
void doubleP(int *a){
  *a = (*a)*2;
}

int main( ){
  int a = 4;
  doubleP(&a);
  cout << a << endl;

  return 0;
}
 #+end_src


*** Side effects
 
 - Effects of a function other than the generation of a value to be returned
   + those that persist
 - e.g., printing stuff using cout, changing a global variable, changing a local variable via call by reference/pointer, etc.  
 
*** Strings
 - Overloading ~+~ and ~[]~ operators
   + C++ libraries provide string facilities
 

 #+begin_src C++
#include <string>

int main( ){
  string h = "hello";
  string w = "world";
  string msg = h + ' ' + w;
  cout << msg << endl;
  return 0;
}
string s = "hello world";
for (int i = 0; i < s.length(); i++)
  cout << s[i] << endl;

 #+end_src


*** Strings

 - Characters are integer values


 #+begin_src C++
char charToUpper(char c){
  if ('a' <= c && c <= 'z')
    return c - 'a' + 'A';
  else
    return c;
}

 #+end_src

*** Strings
 
 - Passing by reference: faster than pass-by-value for large strings
 - Not safe: modifying the passed string also modifies the original one
 - Solution: pass by constant reference 

 #+begin_src C++
string capitalize(const string &s);
 #+end_src

 - Occasionally, you may want to return a value by constant reference (meh!)

 #+begin_src C++
   const string &chooseFirst(const string &s1, const string &s2) {
      if (s1 < s2)
        return s1;
      else
        return s2;
    }
#+end_src

*** Code as Communication
- Passing by constant reference doesn't add any power to the language
  + We can do /less/ things with a const reference
- This is *good*
- Code communicates an intention
  + "This function shouldn't change this string"
- Compiler /checks/ this intention
  + Gives you an error if you violate it

*** Strings
**** Example :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

- Function returning with non-constant reference
 #+begin_src C++
string &chooseFirst(string &s1, string &s2)
{
  if (s1 < s2)
    return s1;
  else
    return s2;
}
int main(){
  string s1 ; "ABC";
  string s2 = "XYZ";
  chooseFirst(s1,s2) = "PQR"
  cout << s1;
  return 0;
}


 #+end_src

**** Ctd :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - chooseFirst( ) returns reference to lexicographically smaller string

 - main( ) prints PQR! since s1=PQR!

*** Modular vs. Application programs (115 vs. 110)
 - Top-down design
   + repeatedly decomposing a complicated problem into smaller, easier subproblems
   + each can be implemented independently
   + e.g., decomposing a function into many smaller ones
 - Alternative is bottom-up approach
   + building reusable tools
   + then using those tools to build even powerful tools
   + eventually solve original problem
 - Reuse
   + reduces the overhead of solving a problem over and over again,
   + saves us from redoing testing and documentation for similar code
   + Easier to understand code
   + Code structured into modules
     - separates interface from implementation

*** Standard input and output
 
 - Can redirect standard input and output from and to files resp.
 
 - ~myProg < inFile > outFile~
 
 - Can pipe the standard output of a program to the standard input of another
 
 - ~myProg1 | myProg2~
 
 
 - See notes for how 
 - ~getline(cin, <string>)~ and ~cin.get(<char>)~ can be used to read input from a file
 
 
 
*** Misc
 

- Separate (unrelated) functions in different files; compile separately using -c command, and link together

  - ~g++ -c main.cpp~
  - ~g++ -c my_util.cpp~
  - ~g++ -o prog.out main.o my_util.o~
 
- Collect all function prototypes together in a header file and include it in main.cpp
 

 #+begin_src C++
#include "my_util.h"
#pragma once preprocessor

 #+end_src
*** Misc
 - Assertions (debugging aid)

 #+begin_src C++
#include <cassert>
...
assert (n>0); //prog. Terminates if not
 #+end_src

* Arrays
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides002-arrays.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil


**   One, two, and multi-dimensional arrays

*** Motivation
- Print 1000 numbers in reverse order

#+begin_src C++
int value0;
int value1;
int value2;
// ...
int value999;

cin >> value0;
cin >> value1;
// ...
cin >> value999;

cout << value999 << endl;
cout << value998 << endl;
// ...
cout << value0 << endl;
#+end_src

*** Motivation (cont'd)
 - How about 1000000 numbers?
 - Tedious, not scalable, and error prone

 - Solution: use aggregate data type
   + homogenous components
   + indexing support
   + constant time access
   + random access


 #+begin_src C++
int a[120000];    // Array declaration

for (int i = 0; i < 120000; i++)
  cin >> a[i];    // Array access
for (int i = 119999; i >= 0; i--)
  cout << a[i] << endl;

 #+end_src

*** Array Operations
- Call the things we store in the array /elements/
- Get the ith element's value: ~array[i]~
- Set the ith element: ~array[i] = someValue;~

*** Simple arrays



#+begin_src C++
const int N = 120000;
int a[N];    // Array declaration

for (int i = 0; i < N; i++)
  cin >> a[i];    // Array access
for (int i = N-1; i >= 0; i--)
  cout << a[i] << endl;


#+end_src

 - Array size must be a constant expression

 - Easy to change size: just update N (the rest of the program remains intact)

*** Passing arrays as arguments


#+begin_src C++
int sumArray(int a[], unsigned int n) // Array argument
{
  int sum = 0;
  for (int i = 0; i < n; i++)
    sum += a[i];
  return sum;
}

int main()
{
  // Array initialization
  int a[] = { 3, 24, -88, 17, -1 };
  cout << sumArray(a, 5) << endl;
}

#+end_src

 - Array size can be left unspecified in array initialization syntax

*** Passing arrays as arguments

 - Array arguments are always automatically passed by reference
 - no special notation is require


 #+begin_src C++
// int sumArray(int& a[], unsigned int n) - INCORRECT
int sumArray(int a[], unsigned int n)    // CORRECT
{
  ...
    }
 #+end_src

 - Works for arrays of all sizes (size is passed as a separate argument)
 - Interface not safe: can modify the content of A

*** A Safer Interface


#+begin_src C++
int sumArray(int a[], unsigned int n)
// not safe, sumArray can modify A!

#+end_src

- Use the following instead:
#+begin_src C++
   int sumArray(const int a[], unsigned int n)
#+end_src

- How to figure out array size when passing n if the size was left unspecified when declaring it?
- use sizeof function:

 #+begin_src C++
int a[] = {1,2,6,3,8};
int x = sumArray(a, sizeof(a) / sizeof(int));

 #+end_src

*** Play time


- Check if integer array sorted
#+begin_src C++
bool arrayIsSorted(const int a[], unsigned int n){
  for (int i = 0; i < n-1; i++){
    if (a[i] > a[i+1])
      return false;
  }
  return true;
}


#+end_src

*** Play time
- Reversing items in integer array
#+begin_src C++
void swap(int &a, int &b) {
  int tmp = a;
  a = b;
  b = tmp;
}
// below a[] is not a constant as want to produce side-effect
void reverseArray(int a[], unsigned int n) {
  for (int i = 0; i < n/2; i++)
    swap(a[i], a[n - i - 1]);
}

#+end_src

*** Processing subarrays

- Compute the sum of an array segment
#+begin_src C++
// pos   : index of the first component in the subarray
// count: total number of components in the subarray
int sumSubarray(const int a[],
                unsigned int pos,
                unsigned int count){
  int sum = 0;
  for (int i = pos; i < pos + count; i++)
    sum += a[i];

  return sum;
}

#+end_src

*** Processing subarrays

- Another way to do the same thing
#+begin_src C++
// begin: index of first component in the subarray
// end   : index of the last component in the subarray
int sumSubarray(const int a[],
                unsigned int begin,
                unsigned int end){
  assert(begin <= end);
  int sum = 0;
  for (int i = begin; i <= end; i++)
    sum += a[i];

  return sum;
}

#+end_src

*** Subtleties

 - C++ does not check if array indices are within bound
 - it's your responsibility
 - Array Copying

 #+begin_src C++
a = b // invalid
 #+end_src

 - copy cell by cell:

 #+begin_src C++
a[6]=b[9] // works!
 #+end_src


*** Subtleties
 - Array Comparison

 #+begin_src C++
if(a == b) // invalid
 #+end_src

 - compare each pair of cells at a time
 - No need to return array as function output, uses call by reference anyway!

*** Prof's Aside
- C++ arrays are /unsafe/
- This is /terrible/ language design
  + Billions of dollars and many security incidents caused by unsafe memory access
  + Error cost outweighs performance cost of checking array bounds
  + Most checks can be optimized out by the compiler
- C++ will never change
  + Backwards compatibility
  + ~std::array~ is safe but isn't the default
- Languages like Rust make sure that these errors are /impossible/
  + Unless you explicitly disable safety


*** Example
#+begin_src C++ :results code :exports both
#include <iostream>
using namespace std;
int main(){
  char passwd[8] = "secret";
  char username[8] = "bob101";
  string toPrint = "";
  // Oops reading past end of array!
  for (int i = 0; i < 16; i++){
    toPrint += username[i];
  }
  cout << toPrint << endl;
}
#+end_src

#+RESULTS:
#+begin_src C++
bob101secret
#+end_src





** Two Dimensional Arrays

*** Motivation


 - Want to store quantity of different products sold in a store
 - but for multiple locations/regions

 - Conceptually can store as a matrix, where rows represent different locations and columns represent different products
 - ~sales[2][1]~ are the total number of items sold for location 2 and product 1
 - recall item n is the (n+1)-th item
   + index starts from 0!

*** Declaration and Access


#+begin_src C++
const unsigned int NUM_OF_REGIONS = 4;
const unsigned int NUM_OF_PRODUCTS = 3;

unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS];

#+end_src

 - To access sales figure for first product in second region, use:

 #+begin_src C++
sales[1][0] // recall, indices start from 0

 #+end_src

 - e.g., want to set sales figure for first product in second region to 500

 #+begin_src C++
sales[1][0] = 500;

 #+end_src

*** Populating and Accessing

#+begin_src C++
// Read input stream
for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
  for (unsigned int product = 0; product < NUM_OF_PRODUCTS; product++)
    cin >> sales[region][product];

// total sales for a particular product (product 0)
unsigned int total_sales = 0;

for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
  // add up sales from all regions for product 0
  total_sales += sales[region][0];

#+end_src

   + Can you compute total sales from region 1?

*** Passing 2D Arrays

 #+begin_src C++
unsigned int sumProductSales(
        unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS],
        unsigned int product)
{
  unsigned int total_sales = 0;
  for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
    total_sales += sales[region][product];

  return total_sales;
}

 #+end_src

 - Can you implement a safer interface?

 - As usual, can leave size of first dimension unspecified, e.g. ~int F(int arr[ ][SIZE])~
 - but not the second one (why?)

*** Making things more modular
- So we can change internal representation without changing interface

#+begin_src C++
// Implement a function that returns
// the value of one element from the sales array
unsigned int getSales(
        const unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS],
        unsigned int r, unsigned int p){
  return sales[r][p];
}
// Implement a function that sets the value
// of one element from the sales array
void setSales(unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS],
              unsigned int r, unsigned int p, unsigned int v){
  sales[r][p] = v;
}

#+end_src

*** Using typedef

- Gives a new name to an existing type
#+begin_src C++
// too lazy to write long types? Use typedef instead!

typedef unsigned int Sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS];

unsigned int sumSales(const Sales sales){
  ...
    }





#+end_src

*** Simulating Two-dimensional Arrays by One-dimensional Ones


#+begin_src C++
unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS];
#+end_src

 - versus

 #+begin_src C++
unsigned int _sales[NUM_OF_REGIONS * NUM_OF_PRODUCTS];
 #+end_src

 - Issue: how to map between these two?
   + row-major vs. column-major order
   + e.g. ~sales[i][j]~
     -  same as ~_sales[i * NUM_OF_PRODUCTS + j]~ in row-major
 - Now you know why the size of the 2nd dimension can't be left unspecified!
   + Can you write the formula for column-major order?

*** Using Row-Major Order


#+begin_src C++
unsigned int totalSales = 0;

for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
  for (unsigned int product = 0;
       product < NUM_OF_PRODUCTS;
       product++){
    totalSales += _sales[region * NUM_OF_PRODUCTS + product];
  }
#+end_src
- This is why we need to know the size of the second dimension
  + To calculate offset

*** Multi-dimensional Arrays

#+begin_src C++
const unsigned int NUM_YEARS = 2;
const unsigned int NUM_REGIONS = 4;
const unsigned int NUM_PRODUCTS = 3;

typedef unsigned int Sales[NUM_YEARS][NUM_REGIONS][NUM_PRODUCTS];

unsigned int total_sales = 0;
for (unsigned int year = 0; year < NUM_YEARS; year++)
  for (unsigned int region = 0; region < NUM_REGIONS; region++)
    for (unsigned int product = 0; product < NUM_PRODUCTS; product++)
      total_sales += sales[year][region][product];

#+end_src

*** Simulating 3d with 1d


 - ~Sales[year][region][product]~

 - vs ~_Sales[(year * NUM_REGS * NUM_PRODS) + (region * NUM_OF_PRODS) + product]~
#+attr_latex: :width 225px
[[./img/all-40_1.png]]
*** Simulating Multi-dimensional Arrays

 - In general for a d-dimensional array with dimensions S_1, S_2, ..., S_d, the element at ~Item[n_1][n_2]...[n_d]~ can be represented as a single dimensional array with the following index


 #+begin_src C++
 _Item[n_d + S_d * (n_{d-1} + S_{d-1}
    * (n_{d-2} + S_{d-2} * (...+S_2*n_1) ... ))]

 #+end_src

* Records
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides003-records.pdf
:++  ND:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
**  Structs
 
*** Motivation

**** Catalog :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

 - E.g. Catalog information in a library
 - Data in collection is heterogenous
 
|-------------+--------------|
| *Title*       | string       |
| *Author*      | string       |
| *Publisher*   | string       |
| *Year*        | unsigned int |
| *Call Number* | string       |
| *Price*       | double       |
|-------------+--------------|

 
 
**** Soln  :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

 - Solution using arrays:

 #+begin_src C++
string titles[N];
string authors[N];
string publishers[N];
unsigned int publishingYears[N];
string callNumbers[N];
double Price[N];

 #+end_src

 - Poor choice of interface!
 - (many arguments to pass for functions)
 
*** Use a record instead!
:PROPERTIES:
:BEAMER_env: column
:END:

**** Col 1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Data can be heterogenous 
 - Define:

 #+begin_src C++
struct CatalogEntry {
  string title;
  string author;
  string publisher;
  unsigned int publishingYear;
  string callNumber;
};
 #+end_src

**** Col 2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Only 1 argument needs to be passed
 - Declare:

 #+begin_src C++
struct CatalogEntry c;
// or, equivalently this:
CatalogEntry c;
 #+end_src

 - Initialize:

 #+begin_src C++
c.title = "Peter Pan";
c.author = "J. M. Barrie";
c.publisher = "Scribner";
c.publishingYear = 1980;
c.callNumber = "B2754 1980";

 #+end_src

*** Initializing a Record
 - As with arrays
 

 #+begin_src C++
CatalogEntry c = {"Peter Pan",
                  "J. M. Barrie",
                  "Scribner",
                  1980,
                  "B2754 1980"};
 #+end_src

*** Copying a Record

 #+begin_src C++
// initialization list
CatalogEntry c = { ... };

// initialization by copying
CatalogEntry c1 = c;

// default initialization
CatalogEntry c2;
// assignment operator
c2 = c;

 #+end_src

*** Functions operating on records
 

#+begin_src C++
void printCatalogEntry(CatalogEntry c){
  cout << "Title: " << c.title << endl;
  cout << "Author: " << c.author << endl;
  cout << "Publisher: " << c.publisher << endl;
  cout << "Publishing Year: " << c.publishingYear << endl;
  cout << "Call Number: " << c.callNumber << endl;
}

#+end_src

 - As usual, by default arguments are passed by value (call by value)
 
 
*** Passing References
 
 - For efficiency, call by reference is also supported
 

 #+begin_src C++
void printCatalogEntry(const CatalogEntry &c){
  cout << "Title: " << c.title << endl;
  cout << "Author: " << c.author << endl;
  cout << "Publisher: " << c.publisher << endl;
  cout << "Publishing Year: " << c.publishingYear << endl;
  cout << "Call Number: " << c.callNumber << endl;
}



 #+end_src

*** Equality checking
 
- Not supported by default
#+begin_src C++
if (c1 == c2)  // invalid

#+end_src

 - As in the case for arrays, must do this each field at a time

 #+begin_src C++
bool CatalogEntryEquals(const CatalogEntry &c1, const CatalogEntry &c2) {
  return c1.title == c2.title && c1.author == c2.author &&
         c1.publisher == c2.publisher &&
         c1.publishingYear == c2.publishingYear &&
         c1.callNumber == c2.callNumber;
}
 #+end_src

*** Complex record data structures
- Arrays of records
#+begin_src C++
CatalogEntry A[3];
CatalogEntry A[] = {{"Peter Pan",
                     "J. M. Barrie",
                     "Scribner",
                     1980,
                     "B2754 1980"},
                    {"C++ Primer",
                     "Stanley B. Lippman",
                     "Addison-Wesley",
                     1998,
                     "QA 76.73 C15 L57 1998"},
                    {"Anatomy of LISP",
                     "John Allen",
                     "McGraw-Hill",
                     1978,
                     "QA 76.73 L23A44"}};
 #+end_src

*** Practise!
 
 - See the very first announcement in UR Courses
 - Try the exercises there
   + declare a C++ struct to represent a point in the Cartesian coordinate system
   + declare a C++ struct to represent a hexagon
   + declare a C++ struct to represent a circle
 
*** Arrays inside of records
 
- Can put arrays as fields of records
#+begin_src C++
const int MAX_NAMES = 100;

struct FullName {
  string name_component[MAX_NAMES];
  int name_count;
};
#+end_src

*** Multi-Dimensional Arrays in Records

#+begin_src C++
const int SCREEN_HEIGHT = 768, SCREEN_WIDTH = 1024;
struct Screen{
  char screen_array[SCREEN_HEIGHT][SCREEN_WIDTH];
};

...

Screen my_screen;
for (int i = 0; i < SCREEN_HEIGHT; i++){
  my_screen.screen_array[i][0] = '*';
 }
#+end_src

*** Mix and Match

**** Col1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+begin_src C++
#include <iostream>
using namespace std;
struct str1 {
  int a[2];
  int b;
};

void func1(str1 A[ ]){
  A[0].a[0] = 10;
  A[0].a[1] = 20;
  A[0].b = 30;
}

int main( ) {
  str1 A[3] = {{{1,0},2}, {{3,0},4},{{0,0},9}};
  func1(A);

  std::cout << A[0].b<<"\n";
  std::cout << A[0].a[1]<<"\n";
}

#+end_src

#+RESULTS:


**** Col2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- What will the ouput be?
** Enums
***  Enumerations

**** Col1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:

 #+begin_src C++ :results output
#include <iostream>
using namespace std;

enum day {
  Sunday = 0,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday
};

#+end_src

**** Col2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src C++
int main() {
  day d;
  d = Thursday;
  d = 1001;

  if (d == Saturday || d == Sunday)
    cout << "Enjoy the weekend!";

  cout << d + 1;
}
#+end_src
 - User-defined data type that consists of integral constants
 - What will the output be?
** Unions
*** Variant records
 - Called ~union~ in C++
 - Multiple component fields can be defined
 - At most one field can be in use at one time (fields share the same memory)
 

*** Example
:PROPERTIES:
:BMCOL:
:END:

**** Example
:PROPERTIES:
:BEAMER_col: 0.7
:END:

#+name: union-example
 #+begin_src C++ :results output :exports both
#include <iostream>
using namespace std;

union Coordinates {
  char a;
  double b;
  char c;
};

int main() {
  Coordinates x;
  x.a = 5;
  // works, prints 5
  cout << x.a << endl;

  x.b = 0.0;  // destroys the value of x.a
  x.c = 'p'; // destroys  x.a and x.b
  cout << x.a << endl; // invalid!
  cout << x.b << endl; // invalid!
  cout << x.c;         // works, prints p
}
#+end_src




**** Result
:PROPERTIES:
:BEAMER_col: 0.3
:END:

- The invalid accesses print garbage
#+RESULTS: union-example
: 
: p
: 5.53354e-322
: p

*** Library Example
 

**** Col1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
enum CatalogEntryType {
  BookEntry, //
  DVDEntry //
};

struct BookSpecificInfo {
  unsigned int pages;
};
#+end_src


**** Col2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
struct DVDSpecificInfo {
  unsigned int discs;
  unsigned int minutes;
};

union CatalogEntryVariantPart {
  BookSpecificInfo book;
  DVDSpecificInfo dvd;
};


#+end_src


*** Example (cont'd)
 

#+begin_src C++
struct CatalogEntry {
  string title;
  string author;
  string publisher;
  unsigned int publishingYear;
  string callNumber;
  CatalogEntryType tag;
  CatalogEntryVariantPart variant;
};


#+end_src

*** Example (cont'd)
 

#+begin_src C++
void printCatalogEntry(const CatalogEntry& c) {
  cout << "Title: " << c.title << endl;
  ...
    cout << "Call Number: " << c.callNumber << endl;
  switch (c.tag) {
  case BookEntry:
    cout << "Pages: " << c.variant.book.pages << endl;
    break;
  case DVDEntry:
    cout << "Discs: " << c.variant.dvd.discs << endl;
    cout << "Minutes: " << c.variant.dvd.minutes << endl;
    break;
  }
}


#+end_src


*** Prof's Aside
- C++ unions are unsafe
  + Without the tag, there's no way to know which type a union contains
  + C++ doesn't require the tag to be there
    - You have to make sure it's there
    - You have to make sure the tag actually matches the data
- Other languages have safe combinations of tags and unions
  + ~enum~ in Rust and Swift
  + Sealed Classes in Java/Kotlin
  + Algebraic datatypes in functional languages (CS 350)

*** Anonymous declaration of records and variant-records
 
 - Earlier:

 #+begin_src C++
union CatalogEntryVariantPart {
  BookSpecificInfo book;
  DVDSpecificInfo dvd;
};

 #+end_src

 - Could have actually declared them in-line:

 #+begin_src C++
union CatalogEntryVariantPart {
  struct BookSpecificInfo { unsigned int pages; } book;
  struct DVDSpecificInfo { unsigned int discs, minutes; } dvd;
};

 #+end_src

*** Anonymous declaration of records and variant-records
 
 - Can also anonymize:
 

 #+begin_src C++
union CatalogEntryVariantPart {
  struct { unsigned int pages; } book;
  struct { unsigned int discs, minutes; } dvd;
};



 #+end_src

*** Anonymous declaration of records and variant-records
 
 - In fact, we could have done the same with the union
 

 #+begin_src C++
struct CatalogEntry {
  string title;
  string author;
  string publisher;
  unsigned int publishingYear;
  string callNumber;
  CatalogEntryType tag;
  union {
    struct { unsigned int pages; } book;
    struct { unsigned int discs, minutes; } dvd;
  } variant;
};
 #+end_src

* Program Organization Principles
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides004-organization.pdf
:header-args:C++:  :includes <iostream> :prologue "using namespace std;"
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 

** Terminology concerning program organization, interface vs. implementation, data encapsulation, information hiding, modularity, layering, design by contract, abstract data types
:PROPERTIES:
:BMCOL:
:END:
 
*** Separation of Concerns
 
 - is a design principle for separating a computer program into distinct sections such that each section addresses a separate concern
 - concern = a set of information that affects code 
 - can be realized via layering and modularity
 
 - Layering: use separate layers in the software, each of which addresses a different concern (e.g., presentation layer, business logic layer, data access layer, etc.)
 
 - *Modularity:* the degree to which a system's components can be separated and recombined
 - break system into parts and to hide the complexity of each part behind an abstraction and interface
 
*** Modularity
 
 - Why bother?
 - Simplifies development and maintenance of computer programs
 - Promote software reuse 
 - Modules can be developed and updated independently (can improve on one section of code without changing other sections)
 
 - How to realize modularity?
   + procedural programming: via functions and top-down design 
 - OOP: via classes and objects 
 
*** Modularity and Refactoring
 
 - *Refactoring* is to rewrite code in order to improve its readability, reusability, or structure without affecting its meaning or behaviour
 - Perhaps older version was poorly written due to time constraints etc.
   + e.g., replace ~306~ with the constant ~SK_CODE1~
   + replace long if-then-else branches with switch/case statements
   + divide overly complex implementation into smaller functions
   + replace with efficient code, etc.


*** Layers of Abstraction
 
 - Each level represents an increasingly detailed model of the software system and its processes
 - at each level, the model is described using concepts appropriate to a certain domain 
 - each higher, more abstract level builds on a lower, less abstract level
 
 - To understand levels of abstraction better, see optional slides on Layering
 
*** Interface vs. Implementation
 - *Interface:* How to use your code (type signature, precondition, postcondition, description of return value)
   + Modular programming: developing software where each section of code is a module with a carefully specified interface
   + makes the purpose of your code clear
   + client software can focus on the interface
     - /and ignore its implementation/
 

*** Interfaces ctd.
   + A crucial aspect of modular programming is mentally separating the interface from the implementation
     - Do you know how ~cin~ and ~cout~ are implemented?
     - You don't need to know to use them
   + We will specify the interfaces in .h files (as well-documented prototypes)
   + We will specify the implementation in .cpp files (primarily as functions)
   + Some functions and variables are not (directly) accessible!

*** Separating interface and implementation
 - Two Approaches
   + via data encapsulation
     - hide variables describing state of the module inside the module
     - (static variables/functions and namespaces)
 
   + by defining new abstract data types (ADT) using records and classes
 
*** The Static Keyword
:PROPERTIES:
:BMCOL:
:END:

- On global variables and functions
  
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
// whatever.cpp

static int foo = 5;
int bar = 6;

static void doh(int var1) {
  // do something
}

void yay(char c){
  // do something
}

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++


// main.cpp

int main ( ){

  extern int foo; // invalid
  extern int bar; // works!

  doh(13); // invalid
  yay('a'); // works!

}

#+end_src


*** Local Variables and static :BMCOL:
 
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.4
:END:

#+name: local-static-example
#+begin_src C++ :results output :exports both
void fun(int var1) {
  int x1=0;
  x1+=var1;
  cout << x1 << endl;
}
void funS(int var1) {
  static int x2=0;
  x2+=var1;
  cout << x2 << endl;
}
int main ( ){
  fun(5);
  fun(5);
  fun(7);

  funS(5);
  funS(5);
  funS(7);
}
#+end_src


**** Column 2
:PROPERTIES:
:BEAMER_col: 0.6
:END:


- Variable value persists across multiple calls to the function
  + Like a global, but can only be accessed from inside the function
  + So other things can't mess it up!

#+RESULTS: local-static-example
: 5
: 5
: 7
: 5
: 10
: 17





*** Namespaces
 
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.35
:END:
- Scope for identifiers
- Avoids name collisions
- Makes it clear where a name is coming from
#+begin_src C++
// myProg.h

#pragma once

namespace myNSpace{
  void Foo();
  int Bar();
}
#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.65
:END:
#+begin_src C++

#include "myProg.h"
using namespace myNSpace;

// use fully-qualified name here
void myNSpace::Foo(){
  // no qualification needed for Bar()
  Bar();
}

int ContosoDataServer::Bar(){
  return 0;
}

#+end_src


*** Anonymous namespaces
 
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.4
:END:
- Used for hiding identifiers
#+begin_src C++
// myProg.h

#pragma once

namespace {
  float foo;
  double pi(){
    return 3.141592653;
  }
}

char bar;

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src C++

// myProg.cpp

#include "myProg.h"

int main(){
  foo = 2.718281828; // invalid!
  double y = pi();        // invalid!
  char c = bar;           // works

  return 0;
}

#+end_src


*** Other Namespace Issues
 
 - Can declare the same namespace over multiple sections
 - Have to be careful about usage of identifiers
 
 - Can have nested namespaces, inline namespaces, namespace aliases, etc.
 
 - Also check out the global namespace
 
*** Data encapsulation
 
 - to place a barrier around the variables that represent the internal state of a software component so that these variables cannot be accessed directly by client code
 - can be achieved via static variables 
 - (restricts variable/function scope to file)
 - hides implementation details
 - clients are forced to use interface to access data
 - similar effects can be achieved using namespaces 
 
*** Separating interface and implementation
 - e.g. A Bounded Counter
 - Start by specifying the interface of the module
 

 #+begin_src C++
// initializeCounter
//
// Purpose: Initialize the bounded counter module.
// Parameter(s):
//  <1> value1: Initial value for the counter
//     expressed as an unsigned integer.
//  <2> upper1: Upper bound for counter value
//     expressed as an unsigned integer.
// Precondition(s): value1 < upper1
// Returns: N/A
// Side effect: The counter is initialized, with value 1
//    the current counter value, and upper1 as the
// upper bound of counter values.

 #+end_src

*** Separating interface and implementation
 

#+begin_src C++
// getCounterValue
//
// Purpose: Retrieve the current value of
// the counter.
// Parameter(s): N/A
// Precondition(s): N/A
// Returns: The unsigned integer value of
// the counter.
// Side effect: N/A

// incrementCounter
//
// Purpose: Increment the value of the
// counter.
// Parameter(s): N/A
// Precondition(s): N/A
// Returns: N/A
// Side effect: The counter value is
// incremented by one. If the incremented
// value reaches the upper bound, then the
// counter value is reset to zero.

#+end_src

*** Complete Interface
 

#+begin_src C++
// encapsulated_counter.h
//
// This module provides ...
// Data encapsulation is used to
// protect the state of the bounded
// counter from manipulation by client
// code, except via the functions in
// the interface.


#pragma once
//initializeCounter
//...
void initializeCounter(unsigned int value1, unsigned int upper1);
// getCounterValue
//...
unsigned int getCounterValue();
// incrementCounter
//...
void incrementCounter();

#+end_src

*** Client Code
 

#+begin_src C++
#include "encapsulated_counter.h"

int main() {
  initializeCounter(0, 3);
  cout << getCounterValue() << endl;
  incrementCounter();
  cout << getCounterValue() << endl;
  incrementCounter();
  incrementCounter();
  cout << getCounterValue() << endl;
  return 0;
}

 #+end_src

- Output:
  + ~0~
  + ~1~
  + ~0~

*** Implementing the Interface
 

#+begin_src C++
// encapsulated_counter.cpp
//
static unsigned int counter_value;
static unsigned int counter_upper;

void initializeCounter(unsigned int value1, unsigned int upper1) {
  counter_value = value1;
  counter_upper = upper1;
}

unsigned int getCounterValue(){
  return counter_value;
}
void incrementCounter(){
  ++counter_value;
  if (counter_value == counter_upper)
    counter_value = 0;
}
#+end_src

 - Note the data encapsulation, the opaqueness of the module, and the separation btw interface and implementation
 
*** Design by contract
 
 - Allows for clean division of labour
 - Specifies the usage convention for a module is captured in a contract between the supplier (the developer of the module) and the client (the user of the module)
 - Protects all parties by specifying
   + supplier's POV: how little is acceptable
   + Client's POV: how much is expected
 - Usually specified using
   + preconditions
   + postconditions
   + invariants
 
*** Design By Contract in our Counter
 

#+begin_src C++
// initializeCounter
//
// Purpose: Initialize the bounded counter module.
// Parameter(s):
//  <1> value1: Initial value for the counter
//    expressed as an unsigned integer.
//  <2> upper1: Upper bound for counter value
//    expressed as an unsigned integer.
// Precondition(s):
//  <1>: value1 < upper1
// Returns: N/A
// Side Effect: The global counter is initialized, with value1 as
//              the current counter value, and upper1 as the upper
//              bound of counter values.

#+end_src


*** Preconditions and Posconditions
 

#+begin_src C++
// encapsulated_counter.cpp
#include <cassert>

void initializeCounter(unsigned int value1, unsigned int upper1){
  assert(value1 < upper1);  // encapsulated_counter.cpp
  counter_value = value1;
  counter_upper = upper1;
}

#+end_src

*** Invariants
 

#+begin_src C++
// initializeCounter
//
// Module invariant: Current counter value is
//  always strictly less than the upper bound
//

static bool isInvariantTrue(){
  return counter_value < counter_upper;
}



#+end_src

*** Invariants ctd.
 

#+begin_src C++
void initializeCounter(unsigned int value1, unsigned int upper1){
  assert(value1 < upper1);
  counter_value = value1;
  counter_upper = upper1;
  assert(isInvariantTrue());
}
unsigned int getCounterValue(){
  assert(isInvariantTrue());
  return counter_value;
}
void incrementCounter(){
  assert(isInvariantTrue());
  ++counter_value;
  if (counter_value == counter_upper)
    counter_value = 0;
  assert(isInvariantTrue());
}

#+end_src

*** Another Example (see the notes)
 
 - Consider designing a timer that represents the accumulated time in [hh:mm:ss] format
 - Internally can be implemented in many ways
 - e.g., only store seconds
 - e.g., store all hours, minutes, and seconds
 - But if interface remains the same, changing implementation does not require changing client code
 
*** Abstract data types (ADT)
 
 - Motivation: returning to our example, we want to have multiple counters
 - ADT:  data type defined by its possible values and operations, e.g.: counters

 #+begin_src C++
// counter.h
//
// This module defines an abstract data type named Counter.
// A counter value is maintained by
// each instance of the Counter type.
// Users may increment or retrieve the value of the counter.
// Data type invariant: Current value of a counter instance
//  must be strictly smaller than its
// upper bound
struct Counter{
  // ... details to be filled out later
};

 #+end_src

*** Abstract data types (ADT)
 

#+begin_src C++
// counterInitialize
//
// Purpose: Initialize a counter instance.
// Parameter(s):
//  <1> counter: A counter instance to be initialized.
//  <2> value1: Initial value for the counter
//    specified as an unsigned integer.
//  <3> upper1: Upper bound for counter value
//    specified as an unsigned integer.
// Precondition:
//  <1> value1 < upper1
// Side Effect: The counter instance is initialized, with value1 as
//              the current counter value, and upper1 as the upper
//              bound of counter values.
//
void counterInitialize(Counter& counter,
                       unsigned int value1,
                       unsigned int upper1);

#+end_src

*** Abstract data types (ADT)
 

#+begin_src C++
// counterGetValue
//
// Purpose: Retrieve the current value of a
// counter instance.
// Parameter(s):
//   <1> counter: A counter instance
// Returns: The unsigned integer value of the
// counter instance.

unsigned counterGetValue(const Counter& counter);

#+end_src

*** Abstract data types (ADT)
#+begin_src C++
// counterIncrement
//
// Purpose: Increment a given counter
// instance.
// Parameter(s):
//   <1> counter: counter instance to be
//    incremented
// Side Effect: The counter value of the
// parameter is incremented by one. If the
// incremented value reaches the upper
// bound, then the counter value is reset to
// zero.
void counterIncrement(Counter& counter);

#+end_src

*** Client Code
 

#+begin_src C++
int main( ){
  Counter c, d;
  counterInitialize(c, 0, 3);
  counterInitialize(d, 0, 10);
  counterIncrement(c);  counterIncrement(c);  counterIncrement(c);
  counterIncrement(d);  counterIncrement(d);  counterIncrement(d);
  cout << counterGetValue(c) << endl;
  cout << counterGetValue(d) << endl;
  return 0;
}
#+end_src

- Outputs
  + 0
  + 3
*** Data Representation, Implementation, Issues :BMCOL:
**** Col1
:PROPERTIES:
:BEAMER_COL: 0.4
:END:

#+begin_src C++
struct Counter {
  unsigned int value;
  unsigned int upper;
};

#+end_src

 - Can implement as before

 - Problems:
   + no data encapsulation
   + no initialization guarantees


**** Col2
:PROPERTIES:
:BEAMER_COL: 0.6
:END:
 - No encapsulation
 #+begin_src C++
Counter c;
counterInitialize(c, 0, 3);
c.value = 999; // allowed!

 #+end_src

 - No initialization guarantees

 #+begin_src C++
// Precondition:
//  <1> The counter module must
// have been properly initialized
Counter c;
cout << counterGetValue(c) << endl;

 #+end_src

* Abstract Data Types via Classes
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides005-adt-classes.pdf
:header-args:C++:  :includes <iostream> :prologue "using namespace std;"
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 
** Declaring ADT as classes, data representation, member functions, public vs. private functions, constructors
:PROPERTIES:
:BMCOL:
:END:
 
*** Counter Example Continued: Interface
 
 - Classes are record types, and thus have fields, but can also declared member functions

 #+begin_src C++
// counter.h
class Counter {
public:
  // initialize
  void initialize(unsigned int value1, unsigned int upper1);
  // getValue
  unsigned int getValue();
  // increment
  void increment();
private:
  // Data representation to follow ...
};

 #+end_src

*** Classes (cont'd)
 
 - Public member functions can be used elsewhere
   + how about public static ones?
 - Private member functions have class scope
   + (cf. file scope as in static or namespaces)

 - Note: member functions no longer take the counter as argument; why?
   + ~void initialize(unsigned int value1, unsigned int upper1)~
 - Public vs. private fields/member functions of a class
   + how to call/invoke public member functions?
   + how to define/implement a member function?
 
*** Client Code :BMCOL:
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.7
:END:
#+begin_src C++
#include "counter.h"

int main( ) {
  Counter c, d;
  c.initialize(0, 3);
  d.initialize(0, 10);

  c.increment(); c.increment(); c.increment();
  d.increment(); d.increment(); d.increment();

  cout << c.getValue() << endl;
  cout << d.getValue() << endl;

  return 0;
}

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.3
:END:
- Outputs:
  + 0
  + 3
- Just like our struct version


*** Some terminology
- *Class*: a type that we define
  + Contains member variables (fields)
  + Has member methods (functions)
  + Members may be public or private
- *Object:* is a value of a class type
  + e.g. a specific instance of a class
- In our example
  + ~Counter~ is a class
  + ~c~ and ~d~ are objects of type ~Counter~

*** Data Representation
 

#+begin_src C++
class Counter {
public:
  ... ... ...
private: // encapsulation
  unsigned int value; // current value of the counter
  unsigned int upper; // upper bound of valid counter values
};

int main() {
  Counter c;
  c.initialize(0, 3);
  c.value = 999; // can't access private data, error!

#+end_src

*** Implementing Methods
 

#+begin_src C++
// counter.cpp
#include "counter.h"

void Counter::initialize(unsigned int value1, unsigned int upper1) {
  assert(value1 < upper1);
  value = value1;
  upper = upper1;
}

unsigned int Counter::getValue() {
  return value;
}

void Counter::increment() {
  value++;
  if (value == upper)
    value = 0;
}
//not using Counter:: will make the
//declarations global!

#+end_src

*** Private Member Functions
 

#+begin_src C++
// counter.h

class Counter {
public:
  ... ... ...
private: // encapsulation
  // isInvariantTrue
  bool isInvariantTrue();
};

// counter.cpp
#include "counter.h"

void Counter::initialize(unsigned int value1, unsigned int upper1) {
  assert(value1 < upper1);
  value = value1;
  upper = upper1;
  assert(isInvariantTrue());
}

#+end_src

*** Fields and Members
- When defining a member methods:
  + All class fields and methods are in scope
  + No need for ~Counter&~ argument like in struct version
- Private Fields and Members
  + Can be used in the /definition/ of public methods
  + Cannot be used outside of class methods


*** Constructors
 
 - Can declare a class constructor
   + special kind of member function
   + automatically invoked when an instance of the class is created
   + intended to perform initialization (forces to initialize when creating instances!)
 - Use this in place of ~Counter::initialize~

 #+begin_src C++
// counter.h
class Counter {
public:
  // Constructor
  // Purpose: Initialize a counter instance
  Counter(unsigned int value1, unsigned int upper1);
  ...
};

 #+end_src

*** The Initialization Guarantee
 

#+begin_src C++
// counter.cpp

Counter::Counter(unsigned int value1, unsigned int upper1){

  assert(value1 < upper1);
  value = value1;
  upper = upper1;
  assert(isInvariantTrue());
}
// clientCode.cpp

int main( ) {
  // We call the constructor *when declaring* the variable
  Counter c(0, 3);
  Counter d(0, 10);
  c.increment();
  ...
    Counter x; // invalid!
}

#+end_src

*** Another example (time accumulator)
 

#+begin_src C++
// time.h
Class Time{
 public:
 // Constructor
 Time(unsigned int hrs,
      unsigned int mins,
      unsigned int secs);
 // increment
 void increment(unsigned int hrs,
                unsigned int mins,
                unsigned int secs);
 // equals
 bool equals(const Time &t);
 // lessThan
 bool lessThan(const Time &t);

#+end_src

*** Interface ctd.
 

#+begin_src C++
// getComponents
// pass in references so we can return multiple values
void getComponents(unsigned int &hrs,
                   unsigned int &mins,
                   unsigned int &secs);
// increment
void increment(unsigned int hrs,
               unsigned int mins,
               unsigned int secs);
// add
Time add(const Time &t);
// diff
Time diff(const Time &t);
private:
// Data representation to follow ...
};

#+end_src

*** Client Code
 

#+begin_src C++
#include "time.h"
int main( ) {
  unsigned int hrs, mins, secs;
  Time t1(0, 30, 45);
  t1.increment(0, 0, 15);
  Time t2(0, 30, 0);
  Time t3 = t1.add(t2);
  Time t4(0, 1, 0);
  Time t5 = t3.diff(t4);
  t5.getComponents(hrs, mins, secs);

  cout << hrs << ':' << mins << ':' << secs << endl;

  Return 0;
}

#+end_src

*** Data Representation and Private Constructor
 

#+begin_src C++
// time.h
class Time {
public:
  ...
private:
  // Another constructor
  Time(unsigned long int secs);



private:
  unsigned long int seconds;
};


#+end_src

*** Implementation
 

#+begin_src C++
// time.cpp
#include <cassert>
#include "time.h"
namespace {
  const unsigned long int SECS_IN_MIN  = 60;
  const unsigned long int MINS_IN_HOUR = 60;
  const unsigned long int SECS_IN_HOUR = SECS_IN_MIN * MINS_IN_HOUR;

  unsigned long int convertToSecs(unsigned hrs,
                                  unsigned mins,
                                  unsigned secs) {
    return hrs * SECS_IN_HOUR + mins * SECS_IN_MIN + secs;
  }
}

#+end_src

*** Implementation
 

#+begin_src C++
// time.cpp
Time::Time(unsigned int hrs,
           unsigned int mins,
           unsigned int secs) {
  assert(mins < 60);
  assert(secs < 60);
  seconds = convertToSecs(hrs, mins, secs);
}
void Time::increment(unsigned int hrs,
                     unsigned int mins,
                     unsigned int secs) {
  assert(mins < 60);
  assert(secs < 60);
  seconds += convertToSecs(hrs, mins, secs);
}

#+end_src

*** Implementation
 

#+begin_src C++
// time.cpp
bool Time::equals(const Time &t) {
  return seconds == t.seconds;
}
bool Time::lessThan(const Time &t) {
  return seconds < t.seconds;
}
void Time::getComponents(unsigned int &hrs,
                         unsigned int &mins,
                         unsigned int &secs) {
  hrs  =  seconds / SECS_IN_HOUR;
  mins = (seconds / SECS_IN_MIN) % MINS_IN_HOUR;
  secs =  seconds % SECS_IN_MIN;
}

#+end_src

*** Implementation
 

#+begin_src C++
// time.cpp

Time Time::add(const Time &t) {
  Time result(seconds + t.seconds);
  return result;
}

Time Time::diff(const Time &t) {
  assert(!lessThan(t));
  Time result(seconds - t.seconds);
  return result;
}

// second constructor!
Time::Time(unsigned long int secs) {
  seconds = secs;
}

#+end_src

*** Remarks
 
 - Note the second (private) constructor on slide 13 and 17
   + used by ~add( )~ and ~diff( )~
   + in general, can have many
 - Could have implemented ~add( )~ and ~diff( )~ differently

 #+begin_src C++
Time Time::a+ - + - + + dd(const Time &t) {
  return Time(seconds + t.seconds);
}
Time Time::diff(const Time &t) {
  assert(! lessThan(t));
  return Time(seconds - t.seconds);
}

 #+end_src

*** More Remarks
 
 - Above alternative implementation creates a temporary, anonymous instance of Time and returns it right away (more efficient)
   + no intermediate variables are declared
 - Another example (where 2 temporary instances are created):

 #+begin_src C++
Time t = Time(1, 0, 45).add(Time(0, 30, 15));
 #+end_src

 - Compilers can usually optimize your code to do this
 
*** Default constructor
 
 - Can give default initial values
   + Constructor with no parameters
   + Invoked by compiler if the client did not invoke another constructor

 #+begin_src C++
// time.h
class Time {
public:
  // Default Constructor
  Time( );
  ...
};
// time.cpp
Time::Time( ) {
  seconds = 0;
}
// client code in main
Time x;
Time y(13,13,13);
Time z( ); // invalid!
 #+end_src

*** C++ classes are records with encapsulated fields :BMCOL:
 
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
struct Time {
  unsigned long int seconds;
};
#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class Time {
public:
  ...
private:
  unsigned long int seconds;
};


#+end_src


*** Structs with Functions :BMCOL:
**** Col1
:PROPERTIES:
:BEAMER_col: 0.35
:END:
 - Only difference: by default, fields are public in structures and private in classes


**** Col2
:PROPERTIES:
:BEAMER_col: 0.65
:END:
#+begin_src C++
struct Time {
public:
  Time();
  Time(unsigned int hrs,
       unsigned int mins,
       unsigned int secs);
  void increment(unsigned int hrs,
                 unsigned int mins,
                 unsigned int secs);
  Time add(const Time &t);
  Time diff(const Time &t);
  bool equals(const Time &t);
  bool lessThan(const Time &t);
  void getComponents(unsigned int &hrs,
                     unsigned int &mins,
                     unsigned int &secs);
private:
  Time(unsigned long int secs);
  unsigned long int seconds;
};
#+end_src


*** Initializing, Assignment, Copying
 

#+begin_src C++
class A { ... };
void func1(A z) { ... }

A x, y;
...
x = y;

...
func1(x);

A func2( ) {
  A x;
  ...
    return x;
}

A z = func2( );


#+end_src

*** Default Initialization
 
 - Just like structures, no initialization is performed by default (unless a constructor is provided)
 - If no constructors are provided, the compiler supplies a dummy one that does nothing!
 

 #+begin_src C++
class A {
  // no constructor declared here
  ...
};
A x; // initialization will not be performed

 #+end_src

*** Passing objects as arguments
 
 - Can be costly
 - better to pass by reference
 - sometimes want to ensure that the passed object is not modified via the ~const~ keyword
 

 #+begin_src C++
int f(const Time &t) {
  if (t.lessThan(Time(0, 30, 0))) // valid: lessThan is const
    t.increment(0, 30, 0);   // invalid: increment is not const
}
 #+end_src

*** const member functions
 

#+begin_src C++
Time add(const Time &t); // in Time class
Time t3 = t1.add(t2);        // in main function

#+end_src

 - How to ensure that member function add doesn't accidentally modify the reference object t1?
 - Use the following declaration instead
   + Note ~const~ keyword /after/ parameter list

 #+begin_src C++
Time add(const Time &t) const; // in Time.h

Time Time::add(const Time &t) const {  // in Time.cpp
  increment(1,15,30); // invalid!
  ...
    }

 #+end_src
* Searching and sorting
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides006-searchsort.pdf
:header-args:C++:  :includes <iostream> :prologue "using namespace std;"
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}

** Linear search, binary search, selection sort, insertion sort
 
*** Notions related to program correctness
 
 - Soundness: is the output always as expected?
   + if the program produced output, then the output is correct
 
 - Completeness: does the program always produce an output?
   + if there exists a solution, then the program will produce an output
 
 - Correct: sound and complete
 
 - Partially correct: sound but not complete 
   + program may not halt on some inputs
 
 - Loop invariant: conditions that are true before the loop and after every iteration
 
*** Linear search: Interface
 

#+begin_src C++
typedef int ItemType;

//
// Helper function: linearSearch
//
// Purpose: Locate the first occurrence of x in the array A.
// Parameter(s):
//  <1> x: An ItemType item to be sought.
//  <2> A: An array of ItemType in which the search
//     is to be conducted.
//  <3> n: An unsigned integer indicating the scope of the search.
// Precondition(s): N/A
// Returns: If x occurs in A[0:n], then the index of
//    the first occurrence will be returned.
// Otherwise, -1 will be returned.
// Side Effect: N/A


#+end_src

*** Linear search: Implementation
 

#+begin_src C++
int linearSearch(const ItemType x,
                 const ItemType A[],
                 unsigned int n) {
  for (unsigned int i = 0; i < n; i++){
    if (x == A[i]){
      return i;
    }
  }
  return -1;
}

#+end_src

 - Time complexity: as the name suggests, linear
   + searching through ~n~ elements takes time proportional to ~n~
   + Twice as many elements -> twice as much time
 
*** Binary search: Idea
 
 - Works correctly on sorted data only
   + Will find some occurrence of searched item x (may not be the first one)
 
 - Check the middle item m 
   + if ~x == m~, we have found ~x~
   + if ~x < m~ then ~x~ will not be located to the right of ~m~, and thus ~x~ should be sought for in the subarray to the left of ~m~
   + if ~x > m~ then ~x~ will not be located to the left of ~m~, and thus ~x~ should be sought for in the subarray to the right of ~m~
 
*** Interface
 

#+begin_src C++
//
// binarySearch
//
// Purpose: To determine if an array contains the specified element.
// Parameter(s):
//  <1> x: The element to search for
//  <2> A: The array to search in
//  <3> n: The length of array A
// Precondition(s): N/A
// Returns: Whether element x is in array A.
// Side Effect: N/A


#+end_src

*** Implementation
 

 #+begin_src C++
bool binarySearch(ItemType x, const ItemType A[], unsigned int n) {
  /*1*/ int low = 0;
  /*2*/ int high = n - 1;

  /*3*/ while (low <= high) {
    /*4*/ int mid = (low + high) / 2;
    /*5*/ if (x == A[mid])
      /*6*/ return true;
    /*7*/ else if (x < A[mid])
      /*8*/ high = mid - 1;
    /*9*/ else
      /*10*/ low = mid + 1;
  } // end while
  /*11*/ return false;
}
 #+end_src

*** Time Complexity
 
 - If the array holds 32 items, needs roughly 5 steps
 - If the array holds 2048 items, needs roughly 11 steps
   + why?
 
 - In general, in the worst case, at most $\log_2(n) + 1$ steps

   + Twice as many items => only one extra step
 
 - Let's analyze the case for 4 items
 - How about 7 items?
 
*** Sorting: Definition
 
 - Rearranging items in some sort of order (either ascending or descending)
 - useful for many applications
 - many known sorting algorithms exist: selection sort, insertion sort, bubble sort, quick sort, merge sort, heap sort, shell sort, radix sort, etc. 
 - each have different performance characteristics (e.g., quick sort is the fastest in the average case, while heap sort and merge sort are the fastest in the worst case)
 
*** The selection sort algorithm: Idea
 
 - The minimum member of the original array will be the first element of the sorted array
 - If we take away the the first element, then the minimum element of the remaining subarray will be the second element in the sorted order
 - If we take away the second element, then the minimum element of the remaining subarray will be the third element in the sorted order
 - ... so on and so forth
 - So, repeatedly select the minimum element from the remaining elements and places it next in the ordering, until all elements have been ordered
 - Example using 2 arrays?
 
*** Two Array Pseudocode
 
 - Sort array A[n]:
 

 #+begin_src C++
for (i = 0; i < n; i++){
 #+end_src

 - 1. find the min element in the unsorted array
 - 2. remove min element from unsorted array
 - 3. place min element at index i of sorted array

 #+begin_src C++
}
 #+end_src

*** One Array Pseudocode
 
 - Sort array A[n]:
 

 #+begin_src C++
for (i = 0; i < n; i++){
 #+end_src

 - 1. find the min element in the unsorted region of array A
 - 2. swap the min element with the element at index i

 #+begin_src C++
}
 #+end_src

*** Loop Invariants
 
 - Recall loop invariants: at the end of each iteration i
   + the subarray A[0..i-1] is a prefix of the sorted array
   + the subarray A[i..n] contains the remaining elements in some arbitrary order
 
 - Refined version:
 

 #+begin_src C++
for (i = 0; i < n; i++){
 #+end_src

 - 1. find the min element in A[i..n]
 - 2. swap the min element with A[i]

 #+begin_src C++
}
 #+end_src

*** Implementation
 

#+begin_src C++
void selectionSort(ItemType A[], unsigned int n){
  for (unsigned int i = 0; i < n; i++){
    unsigned int m = min(A, i, n);
    swap(A[i], A[m]);
  }
}


#+end_src

*** Min Helper Function
 

#+begin_src C++
unsigned int min(const ItemType A[],
                 unsigned int begin,
                 unsigned int end){
  assert(begin <= end);
  unsigned int m = begin;
  for (unsigned int i = begin + 1; i < end; i++){
    if (A[m] > A[i])
      m = i;
  }
  return m;
}


#+end_src

*** Swap Helper Function
 
#+name: swap
#+begin_src C++
void swap(ItemType &x, ItemType &y) {
  ItemType tmp = x;
  x = y;
  y = tmp;
}


#+end_src

*** Another Implementation
 

#+begin_src C++
void selectionSort(ItemType A[], int N){
  int i, j, search_min;
  ItemType temp;

  for (i = 0; i < N; i++) {
    // Find index of smallest element
    search_min = i;
    for (j = i + 1; j < N; j++) {
      if (A[j] < A[search_min])
        search_min = j;
    }
    // Swap items
    temp = A[search_min];
    A[search_min] = A[i];
    A[i] = temp;
  } // end for
}

#+end_src

*** The Insertion Sort algorithm
 
 - Divide the unsorted array into two regions 
   + sorted "left" region/subarray
   + unsorted "right" region/subarray
 - Incrementally take one element from the unsorted region
   + insert it into the sorted region to generate a sorted region that is one element larger
 - Rinse and repeat
 - Sorting happens when inserting element (and not when selecting it)
 
*** Intertion Sort Pseudocode
 
 - Sort A[n]:
 

 #+begin_src C++
for i ranging from 0 to n-1 do {
    Select x = A[i];
    Insert x into sorted region on the left;
  }

 #+end_src

 - Example?
 
*** Invariant
 
 - At the end of each iteration i:
   + the subarray A[0..i] is sorted,
   + while the subarray A[i+1..n] is in some arbitrary order
 
 - Sort A[n]:
 

 #+begin_src C++
for i ranging from 0 to n-1 do {
    Select x = A[i];
    Insert x into subarray A[0..i];
  }

 #+end_src

*** Implementation
 

#+begin_src C++
void insertionSort(ItemType A[], unsigned int n) {
  for (unsigned int i = 0; i < n; i++) {
    ItemType x = A[i];
    // Find insertion point
    unsigned int j = find(x, A, i);
    // Shift elements
    shiftRight(A, j, i);
    // Store element
    A[j] = x;
  }
}

#+end_src

*** Helper Function: Find
 

#+begin_src C++
unsigned int find(ItemType x, const ItemType A[], unsigned int n) {
  for (unsigned int i = 0; i < n; i++) {
    if (A[i] >= x)
      return i;
  }
  return n;
}


#+end_src

*** Helper Function: shiftRight
 

#+begin_src C++
void shiftRight(ItemType A[], unsigned int begin, unsigned int end) {
  assert(0 <= begin);
  assert(begin <= end);

  for (unsigned int j = end; j > begin; j--)
    A[j] = A[j-1];

}


#+end_src

*** Another Implementation
 

#+begin_src C++
void insertionSort(ItemType A[], int N) {
  int i, j, insert_index;
  ItemType x;

  for (int i = 0; i < N; i++) {
    // save the element from position i
    x = A[i];

    // Find the insertion point
    insert_index = 0;
    while ((insert_index < i) && (x > A[insert_index]))
      insert_index++;
    // Shift the elements
    for (j = i; j > insert_index; j--)
      A[j] = A[j-1];

    // Store x at the insertion point
    A[insert_index] = x;
  }
}


#+end_src

*** Bonus: Bubble Sort
- Main idea:
  + Repeatedly go through array
  + Look at side-by-side elements
  + If the left one is bigger, swap them
- Can do with two nested loops
  + After outer loop's run ~i~, the ~i~ largest elements are sorted at end of the array
  + After each inner loop's ~j~ run, the ~i~ th largest element is not in the first ~j~ elements
- See: [[https://www.youtube.com/watch?v=37E3wokWzlU]]

*** Bubble Sort Code
#+begin_src C++ :noweb strip-export :exports both
typedef int ItemType;
<<swap>>
void bubbleSort(ItemType A[], int N){
  for (int i = 0; i < N-1; i++){
    for (int j = 0; j < (N-1)-i; j++){
      if (A[j] > A[j+1]){
        swap(A[j], A[j+1]);
      }}}}

int main(){
  int A[10] = {2, 3, 5, 4, 1, 4, 99, 3000, 0, -33};
  bubbleSort(A, 10);
  for (int i = 0; i < 10; i++){
    cout << A[i] << " ";
  } cout << endl;
}

#+end_src

#+RESULTS:
: -33 0 1 2 3 4 4 5 99 3000

* Constructors and overloading
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides007-ctors.pdf
:header-args:C++:  :includes <iostream> :prologue "using namespace std;"
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 
** Function overloading, type coercion, operator overloading
 
*** Multiset ADT
#+begin_src C++
typedef int ItemType;

class Multiset
{
public:
  // Default constructor
  Multiset();

  bool empty() const;
  bool full() const;
  unsigned int memberCount() const;
  void insert(ItemType x);
  void remove(ItemType x);
  bool member(ItemType x) const;
  void print() const;

private:
  unsigned int data_count;
  ItemType data[MAX_MEMBERS];
};
#+end_src

*** Default constructors (revisited)
 
 - Default constructor written by the programmer
 - constructor creates an empty Multiset
 

 #+begin_src C++
class Multiset {
public:
  Multiset();
  ...
};

 #+end_src
   - Default constructor provided by the compiler
     + Client code: ~Multiset m;~
     + but not ~Multiset m( )~;

*** Declaring another constructor
 
 - Want to insert all elements of an array A of size n into Multiset

 #+begin_src C++
int A[5] = { 2, 5, 4, 3, 1 };
Multiset m;
for (int i = 0; i < 5; i++)
  m.insert(A[i]);

 #+end_src

 - If frequently done, might as well write a constructor

 #+begin_src C++
class Multiset {
public:
  Multiset();
  Multiset(const ItemType A[], unsigned int n);
  ...
};

 #+end_src

*** Using and Implementing the constructor
 
 - Client code

 #+begin_src C++
int A[5] = { 2, 5, 4, 3, 1 };
Multiset m(A, 5);  // Invoking the constructor with an array arg
// followed by an integral argument

 #+end_src

 - Implementation
   + Multiset stored as sorted array

 #+begin_src C++
Multiset::Multiset(const ItemType A[], unsigned int n) {
  assert(n <= MAX_LENGTH);
  data_count = n; // Copy size
  // Copy array
  for (unsigned int i = 0; i < n; i++)
    data[i] = A[i];
  // Sort to normalize representation
  sort(data, data_count);  // e.g., any sorting algorithm
}

 #+end_src

*** Yet Another Constructor
 
 - Want to create a Multiset with n copies of the same item x
 

 #+begin_src C++
Multiset(ItemType x, unsigned int n);

Client code: Multiset m(999, 5);  // A multiset of 5 copies of 999

 #+end_src

 - implementation
 

 #+begin_src C++
Multiset::Multiset(ItemType x, unsigned int n) {
  data_count = n;
  for (unsigned int i = 0; i < n; i++)
    data[i] = x;
}

 #+end_src

*** Other uses of constructors
 - Assignments
 - Anonymous objects can be useful and efficient
 

 #+begin_src C++
// ordinary variables initialized using default constructor
Counter c1, c2;
// ordinary variable initialized using initializing constructor
Counter c3(0, 3);
// unnamed instance constructed with default constructor
c1 = Counter( );
// unnamed instance constructed with initializing constructor
c2 = Counter(0, 10);

Counter ctr1[MAX];
ctr1[5] = Counter(0,3);

 #+end_src

*** Constructor Overloading
- When we define multiple constructors for a class, we say it is /overloaded/
- The compiler picks the right constructor
  + based on the types of the arguments given
  + Can't have two constructors with the same argument types

*** Constructors for  arguments and return values
 
 - Creating anonymous objects for function call

 #+begin_src C++
House h1(500000);
...
House p = h1.add(House(1000000));

 #+end_src

 - Creating anonymous for the purpose of returning it 

 #+begin_src C++
House House::add(const House &other) const {
  if (price == 0 && other.price == 0) {
    // return instance made with default constructor
    return House( );
  }
  else
    return House(price + other.price);
}

 #+end_src

*** Overloading In General
- Can overload any function, not just constructors
  + Again, correct one chosen by argument types

#+begin_src C++
int myMax(int a, int b) {
  if (a > b)
    return a;
  else
    return b;
}
float myMax(float a, float b) {
  if (a > b)
    return a;
  else
    return b;
}
int main( ) {
  // invoke myMax(float, float)
  cout << myMax(1.2f, 4.7f);
  // invoke myMax(int, int)
  cout << myMax(3, 4);
  return 0;}
#+end_src

*** Choosing a Function
 
- Either type or number of args must be different
  + How about different return types only? (nope!)

#+begin_src C++
int myMax(int a, int b) {
  if (a > b)
    return a;
  else
    return b;
}

int myMax(int a, int b, int c) {
  return myMax(a, myMax(b, c));
}

int main( ) {
  // invoke myMax(int, int)
  cout << myMax(3, 4);
  // invoke myMax(int, int, int)
  cout << myMax(3, 4, 5);
  return 0;}
 #+end_src

*** Overloading Class Member Functions

#+begin_src C++
// header
void print( ) const;
void print(ostream &output_stream) const;
// client code
L.print();
L.print(cout);
// definition
void Multiset::print( ) const {
  print(cout);
}
void Multiset::print(ostream& output_stream) const {
  for (unsigned int i = 0; i < data_count; i++) {
    if (i != 0)
      // comma separation for all except the first member
      output_stream << ", ";
    output_stream << data[i];
  }
}

#+end_src

*** Type coercions
 
 - AKA implicit (static or dynamic) type conversion
 - Occurs when evaluating expressions, passing values to functions, and returning values from functions
 - No warning produced by compiler unless has possibility of information loss
 
 - Coercion order:
   + {~double <- float <- long int <- int <- short int <- char~
        + No warnings are provided for type upgrade given in the above order
     - ``safe'' coercion
 
*** Type coercions (examples) :BMCOL:
 
**** Col1
:PROPERTIES:
:BEAMER_COL: 0.6
:END:
#+begin_src C++
void myMax(float f1, float f2); // 1A
void myMax(int i1, int i2); // 1B
myMax(7, 9);


void zipIt(float f1); // 2A
void zipIt(string s1); // 2B
String s = "Trouble";
zipIt(s);

void zoom(float f1); // 3A
void zoom(string s1); // 3B
int x = 14;
zoom(x);

#+end_src

**** Col2
:PROPERTIES:
:BEAMER_COL: 0.4
:END:
 - 1: None (1B)
 - 2: None (2B)
 - 3: Safe (3A) 


*** Type coercions (examples ctd.) :BMCOL:

**** Col1
:PROPERTIES:
:BEAMER_COL: 0.6
:END:
#+begin_src C++

void whoosh(char c1); // 4A
void whoosh(string s1); // 4B
double pi = 3.14159;
whoosh(pi);

void crunch(string s1, string s2); // 5A
void crunch(string s1); // 5B
double e = 2.71828;
crunch(e);

#+end_src

**** Col2
:PROPERTIES:
:BEAMER_COL: 0.4
:END:
 - 4: Unsafe and possibly warning (4A)
 - 5: Error!

*** Type coercions (examples ctd.)
 

#+begin_src C++
void mixed(int i1, double d1); // 6A
void mixed(double d1, int i1); // 6B
int k3 = 3, k4 = 4;
mixed(k3, k4);

void mixed(int i1, double d1); // 7A
void mixed(double d1, int i1); // 7B
double r5 = 55.5, r6 = 66.6;
mixed(r5, r6);

#+end_src

 - 6: both safe but ambiguous 
 - 7: both unsafe and ambiguous
 
*** Operator overloading
 - ~operator~ keyword
   + Gives more than one meaning to the same operator
   + Operands (arguments to operators) are new data types
   + thus, overloading the operator
   + Uses keyword operator
 

 #+begin_src C++
// equality operator
bool operator== (const House &h) const;

// assignment operator
House &operator= (const House &h);

 #+end_src

*** Operator overloading (example)
 

#+begin_src C++
class House {
  string address;
  string owner;
  unsigned int cost;
  bool fireplace;
public:
  // default constructor
  House();

  // initializing constructor

  House(const string &initAddress,
  const string &initOwner,
  unsigned int initCost,
        bool initFireplace);


// copy constructor
House(const House &original);

// equality operator
bool operator== (const House &h) const;

// assignment operator
House &operator= (const House &h);

House &operator+= (const House &h);

House operator+ (const House &h);

void print() const;
};

 #+end_src

*** Implementing ==
 
 - Let's say we want to implement a function called isEquals
 

 #+begin_src C++
bool House::isEquals(const House &h) const {
  if (address != h.address) return false;
  if (owner != h.owner) return false;
  if (cost != h.cost) return false;
  if (fireplace != h.fireplace) return false;
  return true;
}

 #+end_src

 - We could have implemented it as follows
 

 #+begin_src C++
bool House::operator==(const House &h) const {
  ...
    }

 #+end_src

*** The == operator
 
 - Can now use it as an operator 
 

 #+begin_src C++
House h1, h2;
...  // initialize fields of h1 and h2

if (h1 == h2) {
  // do something useful
 }


 #+end_src

*** Implementing assignment operator (=)
- First attempt:

#+begin_src C++
void House::operator=(const House &h) {
  address = h.address;
  owner = h.owner;
  cost = h.cost;
  fireplace = h.fireplace;
}

#+end_src

 - All good, works for a = b 
 - But does not allow assignment statements to be chained 
 - e.g. a = b = c = d won't work
 - for this, need to mutable House type object (i.e. reference)
 
 
*** Implementing assignment operator (=) 
 
- Updated version
#+begin_src C++
// & is used for efficiency only!
House &House::operator=(const House &h) {
  if (this != &h) {
    address = h.address;
    owner = h.owner;
    cost = h.cost;
    fireplace = h.fireplace;
  }
  return *this;
}

#+end_src

 - ~this~ is a pointer to the reference object
 - ~*this~ is the ``contents'' of the reference object
 
 
*** Assignment operator (=) 
- Client code

#+begin_src C++
House h1, h2, h3;
h1.setCost(500); h2.setcost(700); h3.setCost(900);

h1 = h2 = h3;  // same as h1.operator=(h2.operator=(h3));

h1.printCost(); // prints 900



#+end_src

*** Implementing addition operator (+) 
 

#+begin_src C++
House House::operator+ (const House &h) {

  House newHouse;
  newHouse = *this;

  newHouse.address += " + " + h.address;
  newHouse.owner += " + " + h.owner;
  newHouse.cost += h.cost;
  newHouse.fireplace = newHouse.fireplace || h.fireplace;

  return newHouse;
}


#+end_src

*** Implementing increment operator (+=) 
 

#+begin_src C++
House &House::operator+= (const House &h) {

  address += " + " + h.address;
  owner += " + " + h.owner;
  cost += h.cost;
  fireplace = fireplace || h.fireplace;

  return *this;

}


#+end_src

*** Reimplementing addition operator (+) 
 
- Simpler version based on ~+=~
#+begin_src C++
House House::operator+ (const House &h) {

  House newHouse;
  newHouse  = *this;

  newHouse += h;

  return newHouse;

}

#+end_src

*** Overloading non-member operations
 
 - What if you did not write the House class? 
   + can't implement addition (+) as a member function of House!
   + no problem, implement it as a non-member function with an additional House argument (standing for the reference object)
 

 #+begin_src C++
House operator+ (const House &h1, const House &h2) {
  House newHouse;
  newHouse  = h1;
  newHouse += h2;
  return newHouse;
}

 #+end_src

 - Similarly for the case when the first operand is a primitive type
 
*** Stream Operators
 - Similar for stream operator ~<<~ in C++
 - Want to add a stream insertion operator (operator<<) to the House class

 #+begin_src C++
myStream << h1;

void operator<< (ostream &out, const House &h) {
  out << "HOUSE" << endl;
  out << "Location: "  << address   << endl;
  out << "Owner: "     << owner     << endl;
  out << "Cost: "      << cost      << endl;
  out << "Fireplace: " << fireplace << endl;
  out << endl;
}

 #+end_src

 - One issue: fields (e.g. address) are private! 
 
*** Overloading non-member operations
 

#+begin_src C++
class House {
  void print(ostream &out) const;
  ...
};

void House::print(ostream &out) const{
  out << "HOUSE"<< endl;
  out << "Location: "<< address<< endl;
  out << "Owner: "<< owner<< endl;
  out << "Cost: "<< cost<< endl;
  out << "Fireplace: "<< fireplace<< endl;
  out << endl;
}

void House::print() const{
  print(cout);}

void operator<< (ostream &out, const House &h) {
  h.print(out);}


#+end_src

- With this, ~cout << h2;~ works as intended

*** Overloading non-member operations
 
- But ~cout << h2 << endl;~ will give compile time error!

- Use the following implementation instead:
 

 #+begin_src C++
ostream &operator<< (ostream &out, const House &h) {
  h.print(out);
  return out;
}
 #+end_src
 - e.g. The operator returns the stream for the next thing

* Review: Types and Values
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides-review-types.pdf
:header-args:C++:  :includes <iostream> :prologue "using namespace std;"
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

** Leading Towards Polymorphism and Generics

*** Midterm Details
- *March 7* in-class
- Covers all topics up-to and including constructors/overloading
- May cover both conceptual and practical (code)

*** The Road Ahead
- Next unit has a significant increase in the complexity of what we're learning
  + Powerful but complex features of C++
- To lead to that, we're going to review some more of the basics
  + Help catch up


*** What is a value?
- The result of running some computation
  + E.g. ~2~, ~true~, ~{1,2,3,4}~, ~3.1415926535~
- An /expression/ has a value
  + e.g. ~2+2~ and ~1+3~ are different expressions that produce the same value

*** Things that have values
- Variables have values while we're running our program
  + But we might not know what that value is ahead of time
- Arithmetic expressions/using operators
  ~3+4~, ~x/9~, ~2*3*4*5*6~
- Function calls
  + ~f(x)~, ~sqrt(2)~, ~Counter(2,10)~
  + Exception: ~void~ return type
- Array access
  + ~A[3] + 2~
- Class/struct field access
   + ~point.x * -1~


*** Weird things that have values
- The value of ~x = y~ is ~y~'s value
  + So can do ~x = y = z~ to set all to ~z~
- The value of ~stream << "hello"~ is another stream
  + So can chain them together
- The value of ~i++~ is ~i~'s original value
    +  But ~++i~ has the value of ~i~ /after/ adding one

*** Where you can use values
- Right hand side of an assignment
  - ~x = f(3);~
  - ~A[3] = foo.x~
- Argument to a function/operation
  + ~printEntry({1, 2, 3, 4})~
- ~return~ in a function definition
- If a value has a certain type, you can use it /anywhere/ that is expecting that type

*** What is a type?
- A type is a way of classifying values
- Tells you
  + What operations you can perform on a value
  + Which functions can accept that value as an argument
  + What you can do with the return value of a function

*** Values and Types
- Every value in C++ has a type
  + Some values have more than one type
    - e.g. ~1~ can be ~int~, ~unsigned int~, ~double~ etc.
    - More examples after the break

*** Values are NOT types
- ~struct~, ~class~, and ~enum~ are all ways of /defining a new type/
- They don't create any values in your program
  + They create a whole collection of values that you can use  in your program

*** Example: Struct
#+begin_src C++
struct Student{
  string name;
  int studentNum;
  float average;
}
#+end_src
- This defines a new type named ~Student~
  + Doesn't create any specific values
  + Just tells us what they might look like
- Each ~Student~ value contains a value for /each/ field
- Example values:
  + ~{"Alice", 1234, 75.2}~
  + ~{"Bob", 5678, 68.99}~
  + ~{"Eve", 2468, 92.45}~
- Each ~Student~ contains a string AND an int AND a float

*** Types are Interchangeable
- Any type can be used as:
  + The type of a variable
  + The return type of a function
  + The type of a function argument
  + Type type of things inside an array
  + The type of a class/struct field

*** Example: Declaring Variables
- Every time we declare (create a new) variable, it has the form ~TypeName variableName;~
- E.g. ~Counter c;~
  + ~Counter~ is the name of the type;
  + ~c~ is a name that we pick for the variable to have
- Works with any types
  + ~int x;~
  + ~Quadrant q;~
  + ~Point2D p;~
- May need constructor arguments, e.g. ~Counter (3,4);~
- C++ (usually) requires that we specify the type of every variable

*** Example: Enums
#+begin_src C++
enum Direction{
North, South, East, West};
#+end_src
- ~Direction~ is a type
- There are exactly 4 values with type ~Direction~
  +  ~North~, ~South~, ~East~, and ~West~


*** Types are Static
- *Static*: defined/checked at compile-time
- *Dynamic*: defined/checked at run-time
- C++ Types are static
  + Defined at compile-time
- Values are dynamic
  + They exist in memory at run-time
  + Many values of a particular type may exist throughout the run of a program


*** Types in OOP
- A /class/ is a special kind of type
  + Like a struct: specific fields with values
- An /object/ is a value of some class
- Additionally: class has /methods/
  + Functions that are attached to a particular object
  + Call using field-access dot notation
    - ~point.print()~
- Methods can access fields of the object called on
  + Even private

*** Constructors
- A constructor creates an object of a given class
- There may be more than one constructor
  + e.g. They can be /overloaded/
- We /define/ each constructor once
  + In the class declaration
- A constructor is called each time we /create/ a variable of

*** Methods
#+begin_src C++
Counter c;
...
c.increment();
#+end_src
- For a call ~c.increment()~, the program:
  + Looks up the type of ~c~
    - e.g. ~Counter~
  + Looks at the ~Counter~ class definition for a ~Counter::increment()~ method
  + Calls that method as a function

*** What's Different in OOP
- Without OOP, functions exist separately from values
  + Can only access its arguments and globals
- With OOP, a method belongs to a particular value
  + Most operations act on at least one value
  + So we treat the operation as if it is a part of that value
- What this means?
  + Different classes can have different methods of the same name
  + When you call ~foo.bar()~, it looks at the type of ~foo~ to know which code to use

*** Abstract Data Types
- A type where we /don't know exactly what values look like/
  + We just know what operations are supported for the type
  + A collection of operations defining a specific /interface/
  + Can only interact with the type through the interface
- Classes are the realization of the concept of an ADT
  + The interface is the public methods of the class
  + Can only interact with an object of a class through the interface

* Object-oriented design: Composition and Inheritance
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides008-oop-design.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 
** Composition, inheritance, polymorphism, dynamic binding, hidden functions & operators
:PROPERTIES:
:BMCOL:
:END:
 
*** Terminology
 
 - Object-oriented design (OOD): software design technique where the problem domain is decomposed into a set of objects that together solve a software problem
 - Classes (allows us to define ADT)
 - Objects (=class instances)
 - Fields (=class member fields/variables)
 - Methods (=class member functions)
 - Message Passing (=calling of member functions through an object)
 
*** Composition
 
 - Build new classes from existing ones
 - e.g. define a class P1
   + conceptually divide P1 into parts
 - in the defn of P1 class, declare instances of parts
   + (objects of classes, say C1, C2, and C3)
 - C++ compiler will call C1, C2, and C3's default constructors before calls P1's constructor
   + Can call other constructors of C1, C2, and C3 if needed, and pass the appropriate arguments in their parameters
 - Use the methods of C1, C2, and C3 from fields to implement P1 methods
 
*** Composition (example) :BMCOL:

**** Col1
:PROPERTIES:
:BEAMER_COL: 0.35
:END:

#+begin_src C++
class Bicycle {
private:
  Wheel front_wheel;
  Wheel back_wheel;
  Seat seat;

public:
  Bicycle();

 #+end_src


**** Col2
:PROPERTIES:
:BEAMER_COL: 0.65
:END:
#+begin_src C++
  Bicycle(string wheel_manufacturer1,
          string wheel_product1,
          int diameter_in_inches1,
          int weight_in_grams1,
          int spokeCount1,
          string wheel_manufacturer2,
          string wheel_product2,
          int diameter_in_inches2,
          int weight_in_grams2,
          int spokeCount2,
          string seat_manufacturer1,
          string seat_product1,
          string seat_colour1);
  Bicycle(const Bicycle &original);
  Bicycle &operator=(const Bicycle &original);
  void read(istream &in);
  void print(ostream &out);
};
#+end_src

*** Explicit Initializers
- Special syntax to say how to initialize fields for default constructor
 #+begin_src C++
Bicycle::Bicycle()
    : front_wheel(), back_wheel(), seat()
{
  // body of default constructor
}
 #+end_src

 - Could also give arguments depending how ~Wheel~ and ~Seat~ are defined
 - What happens when you declare a Bicycle object?

 #+begin_src C++
Bicycle b;

 #+end_src

*** Initializers in non-default Constructors

 #+begin_src C++

Bicycle::Bicycle(string wheel_manufacturer1,
                 string wheel_product1,
                 int diameter_in_inches1,
                 int weight_in_grams1,
                 int spokeCount1,
                 string wheel_manufacturer2,
                 string wheel_product2,
                 int diameter_in_inches2,
                 int weight_in_grams2,
                 int spokeCount2,
                 string seat_manufacturer1,
                 string seat_product1,
                 string seat_colour1)
    : front_wheel(wheel_manufacturer1, wheel_product1,
                  diameter_in_inches1, weight_in_grams1,
                  spokeCount1),
      back_wheel(wheel_manufacturer2, wheel_product2,
                 diameter_in_inches2, weight_in_grams2,
                 spokeCount2),
      seat(seat_manufacturer1, seat_product1, seat_colour1) {...}
 #+end_src

*** The Constituent Classes :BMCOL:
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class Seat {
private:
  string manufacturer;
  string product;
  string colour;

public:
  Seat();
  Seat(string manufacturer1,
       string product1,
       string colour1);
  Seat(const Seat &original);
  ~Seat();
  Seat &operator=(const Seat &o);
  void read(istream &in);
  void print(ostream &out);
};

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

Seat::Seat(string manufacturer1,
           string product1,
           string colour1)
    // copy constructors
    : manufacturer(manufacturer1),
      product(product1),
      colour(colour1)
{
}

Seat::Seat(const Seat &orig)
  : manufacturer(orig.manufacturer),
    product(orig.product),
    colour(orig.colour) {
}
 #+end_src


*** Calling the Copy Constructor
 
 #+begin_src C++
  Bicycle::Bicycle (const Bicycle &original)
   : front_wheel (original.front_wheel),
     back_wheel (original.back_wheel),
     seat (original.seat)
    {
      // body of copy constructor
    }
 #+end_src

*** Another Example: Safe Arrays
 

#+begin_src C++
typedef int ItemType;

class GuardedArray {
public:
  static const unsigned int LENGTH = 500;
  GuardedArray();
  GuardedArray(ItemType x);
  ItemType retrieve(unsigned int i) const;
  void store(unsigned int i, ItemType x);
private:
  ItemType data_array[LENGTH];
};

#+end_src

*** Implementation
 

#+begin_src C++
GuardedArray::GuardedArray() {
  for (unsigned int i = 0; i < LENGTH; i++)
    data_array[i] = 0;
}

GuardedArray::GuardedArray(ItemType x) {
  for (unsigned int i = 0; i < LENGTH; i++)
    data_array[i] = x;
}

ItemType GuardedArray::retrieve(unsigned int i) const {
  assert(i < LENGTH);
  return data_array[i];
}

void GuardedArray::store(unsigned int i, ItemType x) {
  assert(i < LENGTH);
  data_array[i] = x;
}


#+end_src

*** Managed Array with Insert/Remove
 

#+begin_src C++
class ManagedArray {

public:
  static const unsigned int MAX_LENGTH = GuardedArray::LENGTH;

  ManagedArray();
  ManagedArray(unsigned int n);
  ManagedArray(unsigned int n, ItemType x);

  unsigned int length() const;
  ItemType retrieve(unsigned int i) const;
  void store(unsigned int i, ItemType x);
  void insert(unsigned int i, ItemType x);
  void remove(unsigned int i);

private:
  unsigned int count;
  GuardedArray guaurded_array;

};


#+end_src

*** Implementation (1)
 

#+begin_src C++
ManagedArray::ManagedArray(unsigned int n, ItemType x)
    : guaurded_array(x) {
  assert(n <= MAX_LENGTH);
  count = n;
}

ItemType ManagedArray::retrieve(unsigned int i) const {
  assert(i < length());
  return guaurded_array.retrieve(i);
}


#+end_src

*** Implementation (2)
 

#+begin_src C++
void ManagedArray::insert(unsigned int i, ItemType x) {
  assert(i <= length());
  assert(count < MAX_LENGTH);

  for (unsigned int j = count; j > i; j--)
    guaurded_array.store(j, guaurded_array.retrieve(j-1));
  guaurded_array.store(i, x);
  count++;
}


#+end_src

*** Composition vs. Inheritance
 
 - Can in turn define Multiset using ManagedArray (see notes for full details)
 
 - Another approach (inheritance):
 
   + start with base class (parent/super-class) that gives a vague idea of the objects that we are after
 
   + define other more specialized derived classes (child/sub-classes) that ``inherits'' everything in the parent class
 
   + can create a hierarchy of classes linked by the ancestor-descendant relation
 
*** Inheritance
 - Inheritance lets you /extend/ a class into a new class
   + Child class inherits everything in the parent class
   + when an object of the child class is instantiated,
   + all fields of the parent class will be allocated
 
 - Can can only directly access some fields and methods
   + those that are public (and protected)
   + ~protected~: like ~private~ except child classes can access
 
 - Child class can re-implement some functions of the parent
   + this is called /function overriding/
 
 - Add to this mix the hierarchy of classes
   + e.g. C extends P, GC extends C
   + then all publicly inherited public fields of C will be members of GC
 
*** Inheritance (public vs. private)
:PROPERTIES:
:BMCOL:
:END:
 

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+begin_src C++
class P {
public:
  void f1();
  int f2() const;
  int f3() const;
private:
int v1
int v2;
};



#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src C++


class C : public P {
public:
  void f4();
  double f5() const;
private:
  double v3;
};

 #+end_src

 - what happens when C x is declared?
 - can we access f1 from inside C or its clients?  v1?
 - how can we access v1 from inside C or its clients?
 - what if we wrote ~: private P~?
   + Would make all ~public~ fields of ~P~ private in ~C~
 
*** Inheritance (hierarchy, overriding)
 

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:


 - Can specify a hierarchy: ~GC <: C <: P~

 #+begin_src C++
class C : public P { ... };
class GC : public C { ... };

 #+end_src

 - Can override an inherited function:
#+begin_src C++
class P {
public:
  void f1();
};

void P::f1(){
  // definition 1
}
#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

class C : public P {
public:
  void f1();
  void f2();
};
void C::f1(){
  // definition 2
}
void C::f2(){
  f1(); // which f1?
}
// how to call P's f1() in C?

 #+end_src


*** Inheritance (constructors)
:PROPERTIES:
:BMCOL:
:END:
 
 - Constructor of the base class is implicitly invoked
 - Can specify constructors as well

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class C : ... { ... };
class D : public C {
public:
  D(...);
  ...
  private:
  D1 f1;
  D2 f2;
  ...
};

D::D(...) :
  C(...),
  f1(...),
  f2(...), ...
{ ...   }


#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:


 - To invoke a constructor of D:
   + a constructor C is invoked (which may initiate the invocation of other constructors)
   + a constructor of each member field ~fi~ is invoked (which may initiate the invocation of other constructors)
   + the body of the constructor of D is invoked
 
*** Inheritance (protected)
 


**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Supports more flexibility
#+begin_src C++
class P {
public:
  void f1();
protected:
  void f2();
private:
  int x;
};


#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++


class C : public P {
public:
  void f3();
private:
  int y;
};

class GC : public C {
public:
  void f4();
private:
  int z;
};



 #+end_src


*** Inheritance type
 


**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - All permutations possible
   + ~: public P~ makes all public ~P~ members public in ~C~
   + ~: protected P~ makes all public ~P~ members protected in ~C~
   + ~: private P~ makes all public ~P~ members protected in ~C~
#+begin_src C++
class P {
public:
  void f1();
protected:
  void f2();
private:
  int x;
};

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

class C1 : public P {
  ...
};

class C2 : protected P {
  ...
};

class C3 : private P {
  ...
};

// stronger qualifier ``wins'' !


 #+end_src



 
*** Inheritance type (cont'd)
 

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class P {
public:
  void f1();
private:
  int x;
};

class C : protected P {
public:
  void f3();
};

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++


void C::f3(){
  // all good
  f1();
  // error, not accessible!
  x = 7;
}

int main(){
  P p1;
  C c1;
  // works
  p1.f1();
  // error, not accessible!
  c1.f1();
  ...
    }

#+end_src


*** Example: the Building (base) class

- Make a type that it's impossible to create a value of
  + BUT which is the common parent for other types
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class Building {

protected:
  // default constructor
  Building();

  // assignment constructor
  Building(const string &address1,
           const string &owner1,
           unsigned int cost1,
           unsigned int area1);

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

protected:
  // member variables
  string address;
  string owner;
  unsigned int cost;
  unsigned int area;
};

// Assumes: won't ever create a
// Building object!
 #+end_src


*** Example: the House (child) class
 

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class House : public Building {

public:
  // constructors
  House();

  House(const string &address1,
        const string &owner1,
        unsigned int cost1,
        unsigned int area1,
        unsigned int roomCount1,
        bool fireplace1,
        unsigned int applianceCount1);

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

  // print data
  void print() const;

private:
  // additional member variables
  unsigned int roomCount;
  bool fireplace;
  unsigned int applianceCount;
};
 #+end_src


*** Example: implementation of House

#+begin_src C++
House::House(const string &address1, const string &owner1,
             unsigned int cost1, unsigned int area1,
             unsigned int roomCount1, bool fireplace1,
             unsigned int applianceCount1)
    : Building(address1, owner1, cost1, area1) {
  roomCount = roomCount1;
  fireplace = fireplace1;
  applianceCount = applianceCount1;
}

cout << "HOUSE" << endl;
cout << "Location: " << address;
cout << endl;
... cout << "Bedrooms: " << roomCount;
cout << endl;
...
}
 #+end_src


*** Example: the Barn (base) class
 

#+begin_src C++
class Barn : public Building {
public:
  // constructors
  Barn();

  Barn(const string& address1,
       const string& owner1,
       unsigned int cost1,
       unsigned int area1,
       float hayCapacity1);

// print
void print() const;
private:
// variables
float hayCapacity;

};


 #+end_src

*** Example: client code
 

#+begin_src C++
Barn b1("123 Farmyard Lane", "Jed", 135000, 1000, 24.3);
b1.print();

House h1("321 Walnut Ave", "Clem", 182000, 2400, 3, true, 6);
h1.print();


#+end_src

*** Issues with Inheritance vs. Composition
 
 - Implementation inheritance = examples that we have seen earlier
   + allows code reuse
 
 - Reuse can be done better using composition 
   + easier to understand code
   + encapsulation boundary are better protected
   + fewer interdependencies
 
 - For code reuse, we will almost always use composition rather than implementation inheritance
 
 - More powerful: interface inheritance


* Object-oriented design: Interfaces, Subtying and Polymorphism
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides009-subtyping.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil



** Polymorphism, dynamic binding, hidden functions & operators
:PROPERTIES:
:BMCOL:
:END:
 
*** Interface inheritance
 
 - Rather than reusing implementation, reuse interface!
   + program to an interface, not an implementation
 
 - Say we want to develop 3 similar functions; how to rather implement one?
   + via a common interface
 
 - Key idea:
   + introduce abstract interface (the base class)
   + write the function in terms of this interface
   + develop 3 derived classes that extend this base class and implements (virtual) functions of the base class
   + C++ compiler will do the rest via /dynamic binding/
 
*** Example: Summing All Elements in a List-like structure
- Array version:

#+begin_src C++
int sumArray(const int A[], unsigned int n) {
  int sum = 0;
  unsigned int i = 0;
  while (i < n) {
    sum += A[i];
    i++;
  }
  return sum;
}


#+end_src

*** ManagedArray Version
 

#+begin_src C++
int sumManagedArray(const ManagedArray &A) {
  int sum = 0;
  unsigned i = 0;
  while (i < A.length()) {
    sum += A.retrieve(i);
    i++;
  }
  return sum;
}


#+end_src

*** Standard Input Stream Version
 

#+begin_src C++
int sumStandardInputStream() {
  int sum = 0;
  int next;
  cin >> next;
  while (cin) {
    sum += next;
    cin >> next;
  }
  return sum;
}


#+end_src

*** Reducing Redundancy
- All the examples were doing essentially the same thing
- In Pseudocode:

#+begin_src C++
int sumDataSource(a data source) {
  int sum = 0;
  while (data source has not been exhausted) {
    sum += next entry in the data source;
    exclude the retrieved entry from future consideration;
  }
  return sum;
}


#+end_src

- How can we make this concrete code?

*** Abstract Classes and the Virtual keyword
 
- When we declare a method as virtual, it /must be overridden/ in some child class
  + Give a dummy value of 0
- An /abstract class/ has at least one virtual method
  + Gives /interface/ without an implementation

#+begin_src C++
class DataSource {
public:
  // exhausted
  virtual bool exhausted() const = 0; // pure virtual function
  // next
  virtual int next() = 0; // pure virtual function
};
#+end_src

 - Abstract class can't be instantiated (but can be referenced or extended)
 
*** Generic Code via Abstract Classes
 

#+begin_src C++
int sumDataSource(DataSource &ds) {
  int sum = 0;
  while (! ds.exhausted()) {
    sum += ds.next();
  }
  return sum;
}

#+end_src

 - What's new: can be applied to _instances of any derived class_ of DataSource
 - Called a *polymorphic function*
 
*** Extending the Interface
 
- Array Version
  + Has the same methods as ~DataSource~
  + BUT we specify the concrete representation
    - ~private~ fields

#+begin_src C++
const unsigned ARRAY_DATA_SOURCE_CAPACITY = 1000;

class ArrayDataSource : public DataSource {
public:
  ArrayDataSource(const int A[], unsigned int n);
  virtual bool exhausted() const;
  virtual int next();
private:
  int data[ARRAY_DATA_SOURCE_CAPACITY];
  unsigned int length;
  unsigned int i;
};


#+end_src

*** Implementing the Interface
 
- Must give implementation of each unspecified method from ~DataSource~
#+begin_src C++
ArrayDataSource::ArrayDataSource(const int A[], unsigned int n) {
  assert(n < ARRAY_DATA_SOURCE_CAPACITY);
  for (unsigned int k = 0; k < n; k++)
    data[k] = A[k];
  length = n;
  i = 0;
}
bool ArrayDataSource::exhausted() const {
  return i == length;
}
int ArrayDataSource::next() {
  assert(! exhausted());
  i++;
  return data[i - 1];
}


#+end_src

*** Dynamic Binding

#+begin_src C++
// set up and initialize managed array data source
int A[ ] = { 1, 3, 9, -2 };
ArrayDataSource ads(A, 4);

// call sumDataSouce to add up entries
int sum = sumDataSource(ads);

#+end_src

 - Which version of ~exhausted()~ and ~next()~ to use in ~sumDataSource(ads)~?
   + determined *at runtime*
   + depends on the exact type of object ~ads~ is bound to
     -  In this case, ~ArrayDataSource~
 
*** A Different Instance
- For ~ManagedArray~

#+begin_src C++
class ManagedArrayDataSource : public DataSource {
public:
  ManagedArrayDataSource(const ManagedArray &A);
  virtual bool exhausted() const;
  virtual int next();
private:
  ManagedArray array;
  unsigned int i;
};


#+end_src

*** Implementation

 #+begin_src C++
ManagedArrayDataSource::ManagedArrayDataSource(const ManagedArray& A)
: array(A.length()) {
  for (unsigned int k = 0; k < A.length(); k++)
    array.store(k, A.retrieve(k));
  i = 0;
  }
bool ManagedArrayDataSource::exhausted() const {
  return i == array.length();
}
int ManagedArrayDataSource::next() {
  assert(! exhausted());
  i++;
  return array.retrieve(i - 1);
}

 #+end_src

*** Dynamic Binding for the Managed Array Version
 

#+begin_src C++
// set up and initialize managed array data source
int A[] = { 1, 3, 9, -2 };
ManagedArray ma;
for (unsigned int i = 0; i < 4; i++)
  ma.store(i, A[i]);
ManagedArrayDataSource mads(ma);

// call sumDataSouce to add up entries
int sum = sumDataSource(mads);
#+end_src

- The code of ~sumDataSource~ /has not changed!/
  + But ~next~ and ~exhausted~ functions it was provided have

*** Static Binding Example
- Static means "at compile time"
- C++ uses static by default
  + Not true in other languages (Java, Python)

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+begin_src C++
class C {
public:
  void f() { /* impl 1*/}
  ...
};

class D : public C {
public:
  void f() { /* impl 2*/}
  ...
};


#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src C++



void g(C &c) {
  c.f( );
}

int main() {
  D d;
  // static binding: impl.2 invoked
  d.f();
  // static binding: impl.1 invoked
  g(d);
  return 0;
}


#+end_src


*** Dynamic Binding Example
- Dynamic means "at run time"
  +  ~virtual~ keyword tells C++ to use dynamic binding

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
class C {
public:
  virtual void f() { /* impl 1*/}
  ...
};

class D : public C {
public:
  // implictly virtual
  void f() { /* impl 2*/}
  ...
};


#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++


void g(C &c) {
  c.f( );
}

int main() {
  D d;
  // static binding:
  //    impl.2 invoked
  d.f();
  // dynamic binding: impl.2 invoked
  g(d);
  return 0;
}


#+end_src


*** Overloading is Static
- Overloading, /not overriding/

#+begin_src C++
class E : public C {
public:
  // This does not override f() in class C
  // so it is not implicitly virtual
  void f(int i) { /* implementation 3 */ }
  ...
};

int main() {
  E e;
  e.f();  // static binding: impl.1 invoked
  e.f(4); // static binding: impl.3 invoked
  return 0;
}


#+end_src

*** Polymorphism
- From the Greek
  + /Poly/ : many
  + /Morphos/ : forms
- OOP lets us write one function that works on many types
- This is /subtyping polymorphism/
  + We'll see another kind later
  + If ~A~ extends ~B~, you can use a ~A~ object anywhere a ~B~ is expected
  + If ~A~ extends ~B~, we say ~A~ is a /subtype/ of ~B~

*** What Actually Are Objects?
- We can finally say what an object /is/:
  + An instance of a class
  + Containing a value for each field of that class
  + /and/ containing a pointer to the implementation of each virtual method of that class
- Objects package data and operations together

*** Subyping as a Safer Alternative to Unions
- Recall our library code
 #+begin_src C++
struct CatalogEntry {
  string title;
  string author;
  string publisher;
  unsigned int publishingYear;
  string callNumber;
  CatalogEntryType tag;
  union {
    struct { unsigned int pages; } book;
    struct { unsigned int discs, minutes; } dvd;
  } variant;
};
 #+end_src
 - Can do better with OOP


*** CatalogEntry Abstract Class
- Base class with all of the shared fields
 #+begin_src C++
class CatalogEntry {
public:
  // e.g. an operation we want to do for any entry
  virtual void printInfo();
protected:
  string title;
  string author;
  string publisher;
  unsigned int publishingYear;
  string callNumber;
  // No tag or variant-specific info
};
 #+end_src


*** A Book Subtype
#+begin_src C++
//Book.h
class BookEntry : public CatalogEntry {
public:
 void printInfo();
private:
  int pages;
}
// Book.cpp
void BookEntry::printInfo(){
  // Have all CatalogEntry fields
  // plus pages
  cout << title << author ...
     << pages;
}
#+end_src

*** A DVD Subtype
#+begin_src C++
//Book.h
class DVDEntry : public CatalogEntry {
public:
 void printInfo();
private:
  int discs;
  int minutes;
}
// Book.cpp
void DVDEntry::printInfo(){
  // Have all CatalogEntry fields
  // plus pages
  cout << title << author ...
     << discs << minutes;
}
#+end_src

*** Virtual Override Example
 
 - A function or operator in the base class with the same name and parameters as a function in the derived class
   + can access using the base-class type qualifier

 #+begin_src C++
void Derived1::func() {
  // func() is defined in both
  // the base and the child class Derived1
  Base1::func();
  // ...
}

// same for operators
Derived1 &Derived1::operator=(const Derived1 &original) {
  if (this != &original) {
    // = is defined in both the base and the child class
    Base1::operator=(original);
    field1 = original.field1;
  }
  return *this;
}
 #+end_src

*** Hidden Function Example

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.55
:END:
- Leave ~CatalogEntry::printInfo()~ as virtual, but give it an implementation
#+begin_src C++
void CatalogEntry::printInfo(){
cout << title << author <<
    ... << callNumber;
  }
#+end_src
- ~BookEntry~ and ~DVDEntry~ then only need to deal with their specific fields
  + Can call the base type version for the rest;

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.45
:END:
#+begin_src C++
void BookEntry::printInfo() {
  // Call the base class version
  // to print the shared fields
  CatalogEntry::printInfo();
  // Print our specifc fields
  cout << pages;
}

void DVDEntry::printInfo() {
  CatalogEntry::printInfo();
  cout << discs << minutes;
}
#+end_src



* Templates and Generics
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides010-templates.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 
**  Parametric polymorphism: template functions, template classes
:PROPERTIES:
:BMCOL:
:END:
 
*** Motivation
 
 - Want to define both uniformly
 

 #+begin_src C++
int MaxInt(int a, int b) {
  if (b < a)
    return a;
  else
    return b;
}

double MaxDouble(double a, double b) {
  if (b < a)
    return a;
  else
    return b;
}

 #+end_src

*** Idea
 
 - Can define a generic function with generic parameters
 

 #+begin_src C++
SomeType MaxSomeType(SomeType a, SomeType b) {
  if (b < a)
    return a;
  else
    return b;
}
 #+end_src
 - What properties does ~SomeType~ need for this to work?

*** Implementing using Templates
 
 - Keywords: ~template~, ~typename~
 

 #+begin_src C++
// can also use the keyword class rather than typename
template <typename T>
T Max(T a, T b) {
  if (b < a)
    return a;
  else
    return b;
}

Max<int>(3, 4); // or in most cases, simply: Max(3, 4);


 #+end_src

*** Program organization
 
 - Where should we place function templates?
   + inclusion compilation model vs. separate compilation model
 
 - We will use inclusion compilation model (as it is supported by all compilers)
 
 - Idea: 
   + place template in a header file
   + the compiler will only generate code on instantiation
     - avoids ``code bloat'' suffered by early implementations
 
*** Restrictions on template abstraction
 
- Only works for types which have the necessary operations defined
#+begin_src C++
// works since string class overloads <
Max(string("abc"), string("def"));

Max("abc", "def"); // WRONG, as < is not defined for C strings
// i.e. arrays of characters

#+end_src


*** Restrictions ctd.
 

 - Similarly, won't work for other types that do not define <


 #+begin_src C++
struct Book {
  string author;
  string title;
};

Book b1, b2;
b1.author = "Me";
b1.title = "BestSeller";
b2.author="You";
b2.title= "Whatever!";

Max(b1,b2); // WRONG!


#+end_src
*** Making The Example Work
 - It will compile if we add the following:

 #+begin_src C++
bool operator<(const Book &b1, const Book &b2) {
  return (b1.author < b2.author) ||
         ((b1.author == b2.author) && (b1.title < b2.title));
 #+end_src

 - Only then:
 
 #+begin_src C++
Max(b1,b2); // Works!


 #+end_src

*** Specifying template abstraction
 

#+begin_src C++
// Max.h
//
#pragma once
//
// Max<T>(a, b)
// Purpose: Find the maximum of two given arguments.
// Template Parameter(s):
//  <1> T: A type for which the following operations are defined:
//    -> copy constructor
//       [usually automatically created by C++ compilers]
//    -> binary less than comparison (<)
// Parameter(s):
//  <1> a: An instances of type T
//  <2> b: An instances of type T
// Precondition(s): N/A
// Returns: A T-type value equivalent to the maximum of a and b.
// Side Effect: N/A

#+end_src

*** Reducing the Requirements
 
 - Earlier, could have dropped the copy constructor requirement by passing references instead:
 
 #+begin_src C++
template <typename T>
T &Max(T &a, T &b) {
  if (b < a)
    return a;
  else
    return b;
}

 #+end_src

 - Better implementation as doesn't waste memory by creating temporary objects
 
*** Selection Sort
- Recall, we had ~int~ hard-coded in
#+begin_src C++
typedef int ItemType;

void Swap(ItemType &a, ItemType &b){
  ItemType tmp = a;
  a = b;
  b = tmp;
}
unsigned int FindMin(const ItemType A[],
                     unsigned int begin,
                     unsigned int end){
  ...
    }
void Sort(ItemType A[], unsigned int n){
  for (unsigned int i = 0; i < n; i++){
    unsigned int m = FindMin(A, i, n - 1);
    Swap(A[i], A[m]);
  }
}

#+end_src

*** Generic Helper Functions
 
 - Should work for anything with ~<~

#+begin_src C++
template <typename ItemType>
void Swap(ItemType &a, ItemType &b){
  ItemType tmp = a;        // copy constructor
  a = b;                           // assignment operator
  b = tmp;

}
template <typename ItemType>
unsigned int FindMin(const ItemType A[],
                     unsigned int begin,
                     unsigned int end){
  assert(begin <= end);
  unsigned int m = begin;
  for (unsigned int i = begin + 1; i <= end; i++){
    if (A[i] < A[m])    // less than comparison operator
      m = i;
  }
  return m;
}

 #+end_src


*** A Fully Generic Sort
 
 #+begin_src C++
template <typename ItemType>
void Sort(ItemType A[], unsigned int n){
  for (unsigned int i = 0; i < n; i++){
    unsigned int m = FindMin(A, i, n - 1);
    Swap(A[i], A[m]);
  }
}
 #+end_src

 - Thus the interface should include the following requirements:

 #+begin_src C++
// Template Parameter(s):
//  <1> ItemType: A type for which
//          the following operations are defined:
//    -> copy constructor
//    -> assignment operator
//    -> binary less than comparison (<)

 #+end_src

*** Multiple Typenames
 
 - Can have multiple different type names in template arguments (separated by a comma), e.g.:  

 #+begin_src C++
template <typename T, typename K, typename O>
T func1(K a, O b) {
  T x, y;
  ...
    if (func2(a,b)==x)
    return x;
  else
    return y;
}

 #+end_src

*** Functions as Template Parameters
 
 - Could have generalized our selection sort template to sort either in ascending or in descending order by replacing < with a function

 #+begin_src C++
template <typename T, bool compare(const T &x, const T &y)>
unsigned int Find(const T A[],
                  unsigned int begin,
                  unsigned int end) {
  assert(begin <= end);
  unsigned int m = begin;
  for (unsigned int i = begin + 1; i <= end; i++){
    if (compare(A[i], A[m]))
      m = i;
  }
  return m;
}

 #+end_src

*** Function Parameters ctd.
 
 - New template for sort
 
 #+begin_src C++
template <typename T, bool compare(const T &x, const T &y)>
void Sort(T A[], unsigned int n){
  for (unsigned int i = 0; i < n; i++){
    unsigned int m = Find<T, compare>(A, i, n - 1);
    Swap(A[i], A[m]);
  }
}


 #+end_src

*** Template Client Code
 
- Can explicitly specify which operation to fill the template in with
#+begin_src C++
bool less_than(const int &x, const int &y){
  return x < y;
}
...
Sort<int, less_than>(...);

bool greater_than(const int &x, const int &y){
  return x > y;
}
...
Sort<int, greater_than>(...);

#+end_src

*** Template classes
- Can also define classes in terms of type variables
  + Useful for defining /containers/
  + Want to specify /how/ the data is structured, but not what type it is
- E.g. Guarded arrays
  + Just like before, but not restricted to integer elements
#+begin_src C++
template<typename T>

class GuardedArray {
public:
  static const unsigned int LENGTH = 500;
  GuardedArray();
  GuardedArray(T x);
  T retrieve(unsigned int i) const;
  void store(unsigned int i, T x);
private:
  T data_array[LENGTH];
};

#+end_src


*** Template classes :noexport:
#+begin_src C++
#include <iostream>
#include "headerFile.h"

int main() {
  Comparator<int> c1(7,3);
  std::cout << c1.isLessThan() <<"\n";

  Comparator<double> c2(11.9,5.0);
  std::cout << c2.isLessThan() <<"\n";
}

#+end_src

* Pointers
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides011-pointers.pdf
:header-args:C++:  :includes <iostream> :prologue "using namespace std;"
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
** Directly Managing Memory
:PROPERTIES:
:BMCOL:
:END:

*** The C++ Memory Model
 - We can imagine RAM/Memory as being like a giant array
   + Indicies between ~0~ and ~2^64~
 - With array indices, we could:
   + Get the element at a certain index
   + Set the element at a certain index
   + Do arithmetic on the indices
 - Pointers let you do this /for all of memory/

*** Pointers vs. References
 
 - Reference = alias for another variable
 
 - Pointer = address of another variable stored elsewhere in memory 
 
 - Like references, but much more powerful
   + can be initialized to anything!
   + can change over time (unlike references)
   + can do pointer arithmetic

 - We'll show examples of initialization, the ~&~ operator, and dereferencing (the ~*~ operator)
    + ~x~ vs. ~&x~ vs. ~*x~
 
 
*** Address-Of and Dereferencing
 
- (A)mpersand for (A)ddress-of a variable
  + Produces a pointer from a variable
- ~*~ called /dereferencing/, gets the contents of the address
  + Produces a value from a pointer
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
int *x, *y, p, q;
// vs. int* x, y, p ,q;

p = 5;
q = 6;

x = &p;
y = &q;

if(x==y){
  cout << "Hello";
  cout << "\n";
 }

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

x = y;
cout << *x << "\n";

x = &p;
cout << *x << "\n";

,*x = *y;
cout << *x << "\n";
cout << *&*x << "\n";
cout << **&x << "\n";

#+end_src


*** Review: Pass by Value
 
 - Pass by value
   + Arguments evaluated then copied
   + Can be any value, not just variable
 

 #+begin_src C++
void doubleV(int a){
  a = a*2;
}

int main( ){
  int a = 2;
  doubleV(a+a);
  cout << a << endl;

  return 0;
}
 #+end_src

*** Review: Pass by Reference
 - Pass by reference
   + Argument /must/ be a variable
 

 #+begin_src C++
void doubleR(int &a){
  a = a*2;
}

int main() {
  int a = 4;
  doubleR(a);
  cout << a << endl;

  return 0;
}


 #+end_src

*** New: Pass by Address
 
 - Call by address
   + Arguments evaluated and copied
   + But the thing that's copied is an address in memory
 - Must explicitly dereference to get/set value at that address
 

 #+begin_src C++
void doubleP(int *a){
  ,*a = (*a)*2;
}

int main( ){
  int a = 4;
  doubleP(&a);
  cout << a << endl;

  return 0;
}
 #+end_src


*** Another example: Swap

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Call by address
 

 #+begin_src C++
void swap(int *a, int *b){
  int temp = *a;
  ,*a = *b;
  ,*b = temp;
}

int main( ){
  int a = 4, b = 6;
  swap(&a, &b);
  cout << a << endl;
  return 0;
}
 #+end_src



**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:

- Call by reference

#+begin_src C++
void doubleR(int &a, int &b){
  int temp = a;
  a = b;
  b = temp;
}

int main() {
  int a = 4, b = 6;
  swap(a, b);
  cout << a << endl;
  return 0;
}

 #+end_src


*** Constant pointers
 
- Can get value at address, but not set
**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
struct BigRecord {
  ...
};

void f(const BigRecord *pRec1){
  ...
    BigRecord pRec2;
  ...
    ,*pRec1 = *pRec2; // Wrong!
  pRec1 = pRec2;   // No issues
}

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

int main(){
  BigRecord x;
  ...
    f(&x);
  ...
    }

// Note: f( ) can't change x
// but f( ) can change pRec1!

// vs. BigRecord const *pRec1

#+end_src



*** Arrays are just pointers
- In C++, arrays are just pointers to the start of the array
  + This is why functions don't need the array dimensions in the type
- Array element ~A[i]~ just adds ~i~ to the pointer ~A~.
  + Need the 2nd dimension size to do offset calculation for 2D array
- This is also why arrays are always pass-by-reference
  + The value of an array /is/ its start location in memory, so copying an array just copies its address
  + So the resulting behaviour is pass-by-reference

*** Array Example
- Example:
  #+begin_src C++ :exports both
  int main(){
  int A[5] = {1, 2, 3, 4, 5};
  int i = 3;
  cout << A[i] << endl; //Adds i to address A

  // Also works, but is terrible
  cout << i[A] << endl; //Adds A to address i, same result
  }
  #+end_src

  #+RESULTS:
  | 4 |
  | 4 |

*** Arrays and pointers example
:PROPERTIES:
:BMCOL:
:END:
 

**** Column 1
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
// Every array variable can be
// used as a pointer to the first
// membe of the array
// (with certain restrictions)

int sumArray(int A[],
             unsigned int n){
  int sum = 0;
  for (int i = 0; i < n; i++){
    sum += A[i];
  }
  return sum;
}

#+end_src

**** Column 2
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++

// This is why arrays are
// passed by references
// (by default)

// Array as pointer

int sumArray(int *A,
             unsigned int n){
  int sum = 0;
  for (int i = 0; i < n; i++){
    sum += A[i]; // or, *(A+i)
  }
  return sum;
}

#+end_src



*** Arrays using pointers
 

#+begin_src C++
int A[5] = {1, 5, 10, 15, 20};

cout << A[0];
cout << *(A+0);
cout << *A;
cout << *(A+3);
cout << *A+3;
cout << *(A+3)+3;

A++; // Wrong!

// But this works!
int *B = A; // or int *B = &(A[0]);
B++; // line 11 (see below)
cout << *B;
// compiler automatically increments
// it to the proper location depending
// on the type of data B is pointing to,
// e.g. multiples of 4 for int/float and 8
// for double, etc.


#+end_src

*** C-strings and pointers
 
- C-string are just arrays of characters with the special ~\0~ at the end
  + Unlike c++ ~string~ which is a class
#+begin_src C++
// computing the length of string #1
unsigned int cstringLength(const char s[]) {
  unsigned int length = 0;
  while (s[length] != '\0')
    length++;
  return length;
}

// computing the length of string #2
unsigned int cstringLength(const char *s) {
  unsigned int length = 0;
  while (*(s + length) != '\0')
    length++;
  return length;
}


#+end_src

*** C-strings and pointers (cont'd)
 

#+begin_src C++
// computing the length of string #3
// how it is actually implemented!

unsigned int cstringLength(const char *s) {
  const char *p = s;
  while (*p != '\0')
    p++;
  return p - s; // pointer difference
}

#+end_src

 - In general, given two pointers p and q of the same type, (p - q) is the integer that can be added to p to obtain q.
 
*** Copying Strings using Arrays
 

#+begin_src C++
// string copy using c-string

void cstringCopy(char des[], const char src[]){
  for (unsigned int int i = 0; src[i] != '\0'; i++)
    des[i] = src[i];
  des[i] = '\0';
}


#+end_src

*** Concatenation using Pointers

#+begin_src C++
// string concatenation
void cstringConcat(char des[], const char src[]){
  unsigned int i;
  // find the end of the destination c-string des
  for (i = 0; des[i] != '\0'; i++)
    ; // do nothing
  // append the source c-string src to the end of des
  for (unsigned int j = 0; src[j] != '\0'; j++){
    des[i] = src[j];
    i++;
  }
  // add a c-string terminator to the end of des
  des[i] = '\0';
}


#+end_src

*** Example: Book Records without Pointers
 

#+begin_src C++
// Book record
struct Book {
  string title;
  string author;
  string call_number;
};

// Global Book collection
Book collection[] = {
    {"Computer Security: Art and Science", "Matt Bishop",
     "QA 76.9.A25 B56 2002"},
    {"Applied Cryptography", "Bruce Schneier", "QA 76.9.A25 S35 1996"},
    {"Practical Software Maintenance", "Thomas M. Pigoski",
     "QA 76.76.S64 P54 1996"}};
 #+end_src

*** Example ctd.
 

#+begin_src C++
// function for printing Books
void printBook(const Book &book){
  cout << "title: " << book.title << endl;
  cout << "author: " << book.author << endl;
  cout << "call number: " << book.call_number << endl;
}

// function for finding a Book with some title
unsigned int findBook(const Book collection[], unsigned int n, const string &title){
  for (unsigned int i = 0; i < n; i++){
    if (collection[i].title == title)
      return i;
  }
  return n;
}

#+end_src

*** Example Client Code
 

#+begin_src C++
const unsigned int COLLECTION_SIZE = sizeof(collection) / sizeof(Book);

int main(){
  unsigned int i = findBook(collection,
                            COLLECTION_SIZE,
                            "Applied Cryptography");
  if (i == COLLECTION_SIZE)
    cout << "Book not found" << endl;
  else
    printBook(collection[i]);
  return 0;
}


#+end_src

*** Programming using pointers: Members
 
- What if we only had a /pointer/ to a book?
  + ~o->x~ is the same as ~(*o).x~
  + Convenient for getting fields/methods from pointers
#+begin_src C++

void printBook(const Book *book){
  cout << "title: " << book->title << endl;
  cout << "author: " << book->author << endl;
  cout << "call number: " << book->call_number << endl;
}

#+end_src

*** Programming using pointers: Failure
- You can never get the value from address ~nullptr~
  + aka address ~0~;
- So we can return ~nullptr~ when ~findBook~ fails to find the book
#+begin_src C++
const Book *findBook(const Book collection[],
                     unsigned int n,
                     const string &title){
  for (const Book *p = collection; p < collection + n; p++){
    if (p->title == title)
      return p;
  }
  return nullptr;
}

#+end_src

*** Programming using pointers
 

#+begin_src C++
const unsigned int COLLECTION_SIZE
  = sizeof(collection) / sizeof(Book);

int main(){
  const Book *b = findBook(collection,
                           COLLECTION_SIZE,
                           "Applied Cryptography");
  if (b == nullptr)
    cout << "Book not found" << endl;
  else
    printBook(b);
  return 0;
}
#+end_src
- YOU HAVE TO CHECK if the pointer is null
- Otherwise you'll get a lovely ~segmentation fault~ when you try to dereference


*** A note on Null Pointers
- Sir Tony Hoare, inventor of null pointers:

 #+begin_quote
    I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.
 #+end_quote
- But we're stuck with them
    + Newer languages like Rust and Swift have gotten rid of them


* Dynamic memory management using Pointers :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides012-dyn-pointers.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil

 
** Pointers and New
 
*** Static vs Dynamic allocation
 
 - So far used pointers for allocating space during compile-time only
   + error-prone and might be difficult to understand
   + could have avoided by using arrays and references
 
 - But what if we don't know the size of required memory at compile-time
   + we can allocate memory of size MAX (a constant)
 
 - Problems with this model:
   + might run out of space (despite having a lot of unused memory)
   + can be under-utilized (e.g. if we only use a small part of MAX)
 
 - Solution: allocate memory on demand at run-time!
 
 
 
 
*** Run-time Allocation
 
 - Allocates memory in /heap/ (in contrast to .text, .data, and stack)
 
 - Uses keyword ~new~ to allocate memory

 #+begin_src C++
int *px = new int;
,*px = 777;
cout << *px;
#+end_src

- Must free-up space when done, using keyword delete (otherwise memory leak can happen!)
  + also clean up any dangling pointers using nullptr

 #+begin_src C++
...
delete px;
px = nullptr;

 #+end_src

*** Simple example: Book Record
 

#+begin_src C++
struct Book {
  string title;
  string author;
  string call_number;
};
void printBook(const Book *pBook){
  cout << "title: " << pBook->title << endl;
  cout << "author: " << pBook->author << endl;
  cout << "call number: " << pBook->call_number;
  cout << endl;
}
int main(){
  // allocate a Book from heap
  Book *pb = new Book;
  pb->title = "Security";
  pb->author = "Matt Bishop";
  pb->call_number = "QA.420";
  printBook(pb);
  delete pb; // explicit deallocation
  return 0;}


#+end_src

*** Pictorial representation: Run-time Allocation
 

#+begin_src C++
Book *p;
p = new Book;
p -> title = "Emma";
#+end_src

#+attr_latex: :width 100px
[[./img/book_dynamic1.png]]

*** Safely Allocating Memory
 

#+begin_src C++
Book *pb[10];

for (int i = 0; i < 10; I++){
  pb[i] = new Book;
  pb[i] -> title = "Emma";
 }
#+end_src


#+BEGIN_center
#+ATTR_LaTeX: :height 0.3\textwidth :center
[[./img/uninitialized_array.png]]
...
#+ATTR_LaTeX: :height 0.3\textwidth :center
[[./img/book_static_array.png]]
#+end_center

*** Safely Deallocating Memory
:PROPERTIES:
:BEAMER_env: column
:END:

**** Col 1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src C++
for (int i = 0; i < 10; i++)
  delete pb[i];
#+end_src


#+BEGIN_center
#+ATTR_LaTeX: :height 0.5\textwidth :center
[[./img/uninitialized_array.png]]
#+end_center

**** Col 2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Dangling pointers!
 - assign nullptr to indicate this
 

 #+begin_src C++
for (int i = 0; i < 10; i++)
  pb[i] = nullptr;



 #+end_src

*** The Null Pointer
- If you ever try to dereference ~nullptr~, your program will immediately crash
  + This is /good!/
  + Crashes right at the point of failure
  + Doesn't silently fail and access garbage memory

*** Pointer to dynamic array: Allocation
:PROPERTIES:
:BEAMER_env: column
:END:

**** Col 1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:

#+begin_src C++
Book *parray = new Book[10];
#+end_src


[[./img/book_dynamic_array1.png]]





**** Col 2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_src C++
for (int i = 0; i < 10; i++)
  parray[i].title = "Emma";

// could have also used:
// (parray+i)->title = "Emma";
// (*(parray+i)).title = "Emma";
#+end_src

#+ATTR_LaTeX: :height 0.7\textwidth :center
[[./img/book_dynamic_array2.png]]

*** Pointer to dynamic array: Deallocation
 

#+begin_src C++
Book *parray = new Book[10];

for (int i = 0; i < 10; i++)
  parray[i].title = "Emma";

...

delete [ ] parray;

parray = nullptr;



#+end_src



*** Arrays are just pointers
- An array ~A~ is actually just a pointer to the start of the array in memory
  + This is why arrays are always pass-by-reference
- ~A[i]~ is the same as ~*(A + i)~
  + Get the value ~i~ places after the start of the array
- Why we always need to pass the length of the array
  + Address tells us where it starts, not where it ends

*** Pointer to array of pointers (double pointer): Allocating
:PROPERTIES:
:BEAMER_env: column
:END:

**** Col 1 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.42
:END:
#+begin_src C++
Book **pparray = new Book*[10];
#+end_src

#+ATTR_LaTeX: :height 0.7\textwidth :center
[[./img/book_dynamic_array_pointers1.png]]








**** Col 2 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.58
:END:
#+begin_src C++
for (int i = 0; i < 10; i++){
  parray[i] = new Book;
  parray[i] -> title = "Emma";
 }


#+end_src
[[./img/book_dynamic_array_pointers2.png]]

*** Pointer to array of pointers (double pointer): Deallocating
 

#+begin_src C++
Book **pparray = new Book * [10];

for (int i = 0; i < 10; i++){
  pparray[i] = new Book;
  pparray[i] -> title = "Emma";
 }

#+end_src

 - Deallocation must be done in the reverse order of allocation
 
 
 

 #+begin_src C++
for (int i = 0; i < 10; i++){
  delete pparray[i];
  // following is redundant, since we
  // are about to delete parray
  pparray[i] = nullptr;
 }
delete [] pparray;
pparray = nullptr;



 #+end_src

*** Collection data structures with maximum capacity
- Example: print in reverse order

#+begin_src C++
const int CAPACITY = 1000;

int main(){
  int A[CAPACITY];
  int length;

  cin >> length;

  for (int i = 0; i < length; i++)
    cin >> A[i];


  for (int i = length - 1; i >= 0; i--)
    cout << A[i] << endl;

  return 0;
}


#+end_src

*** Collection data structures w/o maximum capacity

- Example: print in reverse order

#+begin_src C++
int main(){
  int length;
  int *A;

  // Read length of sequence
  cin >> length;

  // Allocate enough memory to hold
  // sequence
  A = new int[length];

  for (int i = 0; i < length; i++)
    cin >> A[i];

  // Write sequence in rev. order
  for (int i = length - 1; i >= 0; i--)
    cout << A[i] << endl;

  // Deallocate memory
  delete [] A;
  return 0;
}


#+end_src

*** Dynamically Expanding and Shrinking: IDea
 
 - Initialize the array with some arbitrary capacity
 
 - Insert integers into the array as usual
 
 - When the array is filled up, expand the capacity of the array as follows:
 - allocate a bigger array
 - copy the contents of the old array to the new one
 - deallocate the old array
 - use the new array to store incoming integers until it is filled up again
 
 - Deallocate the array when it is no longer needed
 
*** Expand/Shrink main function
 

#+begin_src C++
int main(){
  // Initialize encapsulated array
  init();

  // Read sequence
  int x;
  cin >> x;
  while (cin){
    append(x);
    cin >> x;
  }

  // Write sequence in reverse order
  for (unsigned int i = length(); i > 0; i--)
    cout << retrieve(i - 1) << endl;

  // Deallocate encapsulated array
  cleanup();

  return 0;
}


#+end_src

*** Initializing
 

#+begin_src C++
// Amount of memory available
unsigned int array_capacity = 0;
// Amount of memory used
unsigned int array_length = 0;
// Actual memory resource
int *array = nullptr;

bool isInitialized(){
  return (array != nullptr);
}

void init(){
  assert(! isInitialized());
  // Default initial capacity
  array_capacity = 4;
  // Array is empty initially
  array_length = 0;
  // Allocate array
  array = new int[array_capacity];
  assert(isInitialized());
} // end init()



#+end_src

*** Example: Append for shrinking/growing
 

#+begin_src C++
void append(int x) {
  assert(isInitialized());

  // Expand capacity if full
  if (array_length == array_capacity)
    expand();

  // Append to the end
  array[array_length] = x;
  // Update array length
  array_length++;
}


#+end_src

*** Expand for Shrinking/Growing
 

#+begin_src C++
void expand() {
  assert(isInitialized());
  assert(array_capacity > 0);
  assert(array_length == array_capacity);

  // Calculate new capacity
  int new_array_capacity = array_capacity * 2;
  // Allocate bigger array
  int *new_array = new int[new_array_capacity];

  // Copy contents
  for (unsigned int i = 0; i < array_length; i++)
    new_array[i] = array[i];
  // Deallocate old array
  delete[] array;

  // Use new array and update capacity
  array = new_array;
  array_capacity = new_array_capacity;
  assert(array_length < array_capacity);
}
#+end_src

*** Shrinking/Growing: Retrieve and Cleanup

#+begin_src C++
unsigned int length(){
  assert(isInitialized());
  return array_length;
}

int retrieve(unsigned int i){
  assert(isInitialized());
  assert(i < length());
  return array[i];
}

void cleanup(){
  assert(isInitialized());
  // Deallocate memory resource
  delete [] array;
  // Establish postconditions
  array = nullptr;
  array_capacity = 0;
  array_length = 0;
  assert(! isInitialized());
}

#+end_src

*** Dynamically allocated 2d arrays
 

#+begin_src C++
// allocate the 2D array
int** pparray;





pparray = nullptr;





pparray = new int*[10];







#+end_src

*** Dynamically allocated 2d arrays
 

#+begin_src C++
// allocate the 2D array
int** pparray = nullptr;
pparray = new int*[10];

for (unsigned int i = 0; i < 10; i++){
  pparray[i] = new int[20];
 }






#+end_src

*** Dynamically allocated 2d arrays
 

#+begin_src C++
// store 7 in position 6 of row 2
pparray[2][6] = 7;

#+end_src

 - How about using pointers?
 

 #+begin_src C++
// when done:
// deallocate in reverse order
for (unsigned int i = 0; i < 10; i++)
  delete [] pparray[i];
delete [] pparray;







 #+end_src

*** Dynamic memory management and ADTs
 
 - Why handle manually when we can automate allocation using constructors and deallocation using destructors?
 
 - design a wrapper class for c-strings for 
   + allocating and deallocating memory for c-strings 
   + streamline the copying and concatenation of c-strings 
 
 
 
 
 
 
*** String example (cont'd)
 

#+begin_src C++
class String {
public:
  ...
unsigned int length() const;
  char member(unsigned int i) const;
  ...
  private:
  const char *buf;
};




unsigned int String::length() const {
  return strlen(buf);
}

char String::member(unsigned int i) const {
  assert(i < length());

  return buf[i];
}


#+end_src

*** String example (cont'd)
 

#+begin_src C++
class String {
public:
  String(const char *s);

  unsigned int length() const;
  char member(unsigned int i) const;

private:
  const char *buf;
};

// Usage: String s("Hello World");
// Alternate syntax: String s = "Hello World";
// implementation

String::String(const char *s) {
#+end_src

char *newbuf 

#+begin_src C++
= new char[strlen(s) + 1];
strcpy(newbuf, s);
buf = newbuf;
}


#+end_src

*** String example (cont'd)
 

#+begin_src C++
class String {
public:
  String(const char *s);
  ~String();     // Destructor prototype

  unsigned int length() const;
  char member(unsigned int i) const;

private:
  const char *buf;
};


// Usage

    { // begin of scope
      String s = "Hello World";
      ...
        } // end of scope: memory should be
// reclaimed here

// Implementation

String::~String() {
  delete [] buf;
}


#+end_src

*** String example (cont'd)
 

#+begin_src C++
class String {
public:
  String();        // Default constructor
  String(const char *s);
  ~String();     // Destructor prototype

  unsigned int length() const;
  char member(unsigned int i) const;

private:
  const char *buf;
};


// Implementation

String::String(){
  // Create a c-string of length 0
  char *newbuf = new char[1];
  newbuf[0] = '\0';
  buf = newbuf;
}


#+end_src

*** String example (cont'd)
 

#+begin_src C++
class String {
public:
  String();
  String(const char *s);
  String(const String &original);
  ~String();

  unsigned int length() const;
  char member(unsigned int i) const;

private:
  const char *buf;
};
// deep copying intended

String::String(const String &original) {
  unsigned int len = original.length();
#+end_src

char* nonConstBuf 

#+begin_src C++
= new char[len + 1];
strcpy(nonConstBuf, original.buf);
buf = nonConstBuf;
}

// is the & before original really required?

#+end_src

*** String example (cont'd)
 
 - Three different uses:
 

 #+begin_src C++
// for initializing a string object by another
String s("Hello"); // Const. invoked
String t(s);           // Copy const. invoked

// Alternative syntax
String s = "Hello"; // Const. invoked
String t = s;           // Copy const. invoked

// for passing String args. by value
void f(String s){
  ...
    }
...
String t = "Hello";
f(t);    // Copy const. invoked

// for returning string instances as value
String f(...){
  String s;
  ...
    // Copy const. invoked to create
    // return value
    return s;
}





 #+end_src

*** String example (cont'd)
 
 - Can the & before &original be left out?
 

 #+begin_src C++
String::String(const String &original) {
  unsigned int len = original.length();
  char *nonConstBuf = new char[len + 1];
  strcpy(nonConstBuf, original.buf);
  buf = nonConstBuf;
}

 #+end_src

 - No: The copy constructor is always invoked whenever an argument of the type is passed by value to any function
 - so if & is left out, it will repeatedly call the copy constructor till the stack overflows!   
 
 
 
*** String example (cont'd)
 

#+begin_src C++
class String {
public:
  // it's a good idea to follow this standard prototype for = operator
  // try (a=b)=c with a cons String & return type and you'll see why this is important!
  String &operator=(const String &original);  // Assignment operator
  ...                                                        // try (a=b)=c with a cons String & return type!
  private:
  const char *buf;
};

String s;                 // default constructor
String t = "Hello";  // auxiliary constructor
String u(t);             // copy constructor
s = u;                    // assignment operator

#+end_src

*** String example (cont'd)
 

#+begin_src C++
String &String::operator=(const String &original) {
  unsigned int len = original.length(); // len is length of string to be copied
  char *nonConstBuf = new char[len + 1]; // allocate new space of size len
  strcpy(nonConstBuf, original.buf); // copy original string to new space (Line 4)
  delete [] buf; // deallocate old string (Line 5)
  buf = nonConstBuf; // make old string pointer point to newly allocated space

  return *this;
}

// a potential issue
String s = "Hello, World";
s = s;   // Self assignment! Q: Is there anything wrong with this?
// Ans. might do extra work; even more problematic if Line 5 is moved before Line 4


#+end_src

*** String example (cont'd)
 

#+begin_src C++
String &String::operator=(const String &original) {
  if (&original != this){
    unsigned int len = original.length(); // len is length of string to be copied
    char *nonConstBuf = new char[len + 1]; // allocate new space of size len
    strcpy(nonConstBuf, original.buf); // copy original string to new space
    delete [] buf; // deallocate old string
    buf = nonConstBuf; // make old string pointer point to newly allocated space
  }

  return *this;
}



#+end_src

*** Concatenation
 

#+begin_src C++
class String {
public:
  ...
String &append(const String &s);
  ...
  private:
  const char *buf;
};

// note: none of the following work
// void append(const String &s)
//  String append(const String &s)

String s = "Hello";
String t = " World";
s.append(t);            // "Hello World"

String s = "Hello";
String t = " ";
String u = "World";
s.append(t).append(u);


#+end_src

***
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 - Allocate a buffer that is big enough to hold both the content of the current object and that of the argument
 
 - Copy the content of the current object to the beginning of the buffer
 
 - Append the content of the argument to the end of the buffer
 
 - Delete the original content of the current object
 
 - Install the buffer into the current object
 
 
*** Concatenation
 

#+begin_src C++
String &String::append(const String &s){
  unsigned int len = strlen(buf) + strlen(s.buf);
  char *newbuf = new char[len + 1];
  strcpy(newbuf, buf);
  strcat(newbuf, s.buf);
  delete [] buf;
  buf = newbuf;

  return *this;
}


#+end_src

*** Concatenation
 
 - append is a mutation operation, let's formulate a creation version
 

 #+begin_src C++
String concatenate(const String &s) const; // prototype

// usage
String s = "Hello";
String t = " World";
String u = s.concatenate(t);

// implementation
String String::concatenate(const String &s) const {
  return String(*this).append(s);
}


 #+end_src

*** Concatenation
 
 - Efficient only if supported by the compiler
 - First, let's define a private helper constructor
 

 #+begin_src C++
String::String(const char *s, const char *t) {
  unsigned int len = strlen(s) + strlen(t);
  char *newbuf = new char[len + 1];
  strcpy(newbuf, s);
  strcat(newbuf, t);
  buf = newbuf;
}

String String::concatenate(const String &s) const {
  return String(buf, s.buf); // still calls the copy constructor, but some smart compilers
}                                            // will be able to recognize and avoid this unnecessary task

 #+end_src

* Dynamic memory management and OOP :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides013-dyn-oop.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
** Interaction between dynamic memory management and OOD features, such as composition, inheritance, and dynamic binding
 
*** Composition and inheritance
 
 - Recall invocation seq. of const.
 

 #+begin_src C++
class C : ... {
  ...
    };
 #+end_src

 - Invocation sequence does not depend on the order in which constructors are called, but as follows:
 - const. of base class
 - const. of member vars, in the order they are defined
 - body of the constructor 

 #+begin_src C++
class D : public C {
public:
  D(...);
  ...
  private:
  D1 f1;
  D2 f2;
  ...
};

D::D(...) : C(...), f2(...), f1(...), ... {
  ... // body
    }

 #+end_src

*** Constructor invocation sequence example
 

#+begin_src C++
class C {
public:
  C();
  C(const char *s);
};
C::C() {
  cout << "C()" << endl;
}
C::C(const char *s) {
  cout << "C(const char *)" << endl;
}
class D : public C {
public:
  D();
};


D::D() : C() {
  cout << "D()" << endl;
}
class E : public D {
public:
  E();
private:
  C x;
  C z;
};
E::E() : D(), x("Hello"), z("Goodbye"){
  cout << "E()" << endl;
}
int main() {
  E y;
  return 0;
}

#+end_src

*** Destructor invocation sequence
 
 - Destructor invocation sequence is exactly the opposite of that of the constructor!
 

 #+begin_src C++
class C : ... {
  ...
    };

 #+end_src

 - When an object of type D goes out of scope, ~D() is called, which executes its body, then calls ~C2(), then ~C1(), and finally ~C() 
 
 
 

 #+begin_src C++
class D : public C {
public:
  ...
~D();
private:
  C1 f1;
  C2 f2;
  ...
};

D::~D() {
  ... // body of ~D()
    }


 #+end_src

*** Destructor invocation sequence (cont'd)
 

#+begin_src C++
class C{
public:
  ~C() { cout << "~C()" << endl; }
};

class C1 : public C {
public:
  ~C1() { cout << "~C1()" << endl; }
};

class C2 : public C {
public:
  ~C2() { cout << "~C2()" << endl; }
};

class D : public C {
public:
  ~D() { cout << "~D()" << endl; }
private:
  C1 x;
  C2 y;
};

int main() {
  D z;
  return 0;
}


#+end_src

*** Constructors and destructors
 

#+begin_src C++
String *ps = new String; // calls constructor as usual

String *ps = new String("Hello"); // can also specify which constructor to use

delete ps; // (explicitly) calls the destructor


#+end_src

*** Recall: static vs. dynamic binding
 

#+begin_src C++
class C {
public:
  virtual void f() { /* implementation 1 */ }
  ...
};

class D : public C {
public:
  // implictly virtual
  void f() { /* implementation 2 */ }
  ...
};



void g(C &c) {
  c.f( );
}

int main() {
  D d;
  d.f();  // static binding: impl.2 invoked
  g(d);  // dynamic binding: impl.2
  // invoked
  return 0;
}


#+end_src

*** Virtual destructor
 

#+begin_src C++
class C {
public:
  // Say this is an abstract class
  ...
~C();  // WRONG, use virtual ~C() instead
};

class D : public C {
public:
  ...
~D();
private:
  ...
};
void destroy(C *ptr) {
  ...
    delete ptr; // wanted to call ~D()
  ...
    }

int main() {
  C *p = new D;
  destroy(p);
  return 0;
}

#+end_src

*** Using classes that involve dynamically allocated memory
 
 - If you craft your class properly by equipping it with: 
 - a default constructor 
   + a copy constructor 
 - an assignment operator and 
 - a destructor 
 - then you may simply treat the class as a built-in type
 
*** Example (using String to define Book)
 

#+begin_src C++
class Book {
public:
  Book(const String &a, const String &t);
  Book(const Book &b);
  ~Book();
  Book &operator=(const Book &b);
  ...
  private:
  String author;
  String title;
};

#+end_src

 - Book::Book(const String &a, 

 #+begin_src C++
const String &t) : author(a), title(t) { }
Book::Book(const Book &b) : author(b.author), title(b.title) { }

Book &operator=(const Book &b){
  if (&b != this){
    author = b.author;
    title = b.title;
  }
  return *this;
}

Book::~Book() { }

 #+end_src

*** Polymorphism
 
 - Base class pointer = child class instance : works as expected
 - Child class pointer = base class instance : WRONG
 

 #+begin_src C++
class Critter {
  ...
};

class Spider : public Critter {
  ...
};

Critter *cp = new Spider(...); // works
Spider *sp1 = new Critter(...); // WRONG!
Spider *sp2;
sp2 = cp; // WRONG!


 #+end_src

*** Polymorphism with pure virtual functions
 

#+begin_src C++
class Critter {
private:
  int legCount;
public:
  Critter(int n);
  virtual void print() = 0;
};

Critter::Critter(int n){
  legCount = n;
}

// Note: there is no implementation for the
// pure virtual function named print


class Spider:  public Critter{
private:
  bool poisonous;
public:
  Spider(bool poisonous1);
  virtual void print();
};

void Spider::print(){
  // body implements virtual func.
}

Spider *sp = new Spider(true);
sp->print();
Critter *cp = sp;
cp->print(); // dynamic binding

#+end_src

*** Polymorphism and dynamic arrays
 

#+begin_src C++
Critter *critter_array[100];
for (int i = 0; i < 100; i++) {
  if (i % 2 == 0)
    critter_array[i] = new Spider(false);
  else
    critter_array[i] = new Ant(6, 50);
 }






Critter **critter_array = new Critter*[100];
for (int i = 0; i < 100; i++) {
  if (i % 2 == 0)
    critter_array[i] = new Spider(false);
  else
    critter_array[i] = new Ant(6, 50);
 }


#+end_src

* Canonical forms for C++ classes :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides014-canonical.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 
 
** Canonical form (definition)
 
 - A C++ class is in canonical form if it provides the following four member functions/operators:
 - default constructor
 - copy constructor
 - destructor
 - assignment operator
 
 - These are otherwise provided by default
 - unless some constructor other than the copy constructor is provided for a class, then the default constructor is not provided by default!
 
 - The reason for putting a class in canonical form: to avoid memory leaks and to make call by value and return from functions work as expected
 
 
 
** How to write a copy constructor
 
 - MyClass::MyClass(const MyClass &original)

 #+begin_src C++
: MyBaseClass(original), // delegate copying of base class fields to its own cc
    field1(original.field1),    // delegate copying of field1 to its own cc, etc.
 #+end_src

 -        field2(original.field2),
 -        field3(original.field3)

 #+begin_src C++
// ...
    {

      // do everything that is required to perform a deep copy of original fields to the
      // reference object fields

    }


 #+end_src

** How to write a destructor
 
 - MyClass::~MyClass()

 #+begin_src C++
    {
      // usually empty (unless code performed dynamic allocation)

      // free/deallocate all dynamically allocated memory in the reverse order of their
      // allocation order
    }

 #+end_src

 - A virtual destructor should be used for any class that is involved in inheritance, i.e., for any base class or any derived class (see week 10 slide 46)
 - if in doubt, make it virtual

 #+begin_src C++
virtual ~MyClass();
 #+end_src

 - never make it purely virtual, however (provide implementation regardless)
 - don't attempt to invoke base-class destructor (will be done automatically)
 
** How to write an assignment operator
 

#+begin_src C++
MyClass &MyClass::operator=(const MyClass &original){
  if(&original != this) // don't assign to itself
    {
      // 1. everything in destructor (to get rid of the existing value of this reference instance)
      // 2. Everything in the copy constructor (to copy original's fields to reference instance)
      // 2a. if this is a derived class, add this line
      MyBaseClass::operator=(original);

      // 2b. if the copy constructor copies fields using the ":" syntax (i.e., an initializer list),
      // add these lines
      field1 = original.field1;
      field2 = original.field2;
      field3 = original.field3;

      // 2c. everything in copy constructor body
    }
  return *this;
}


#+end_src

** Example: the Committee class
 

#+begin_src C++
class Committee { // a class with dynamic allocation
private:
  float *pbudget;
  string *pmembers[10];

public:
  // Default Constructor
  Committee();

  // Copy Constructor
  Committee(const Committee &original);

  // Destructor
  ~Committee();

  // Assignment Operator
  Committee &operator=(const Committee &original);
};

#+end_src

** The Committee class (default constructor)
 

#+begin_src C++
// Default Constructor

Committee::Committee() {

  pbudget = new float(0.0f);

  for (int i = 0; i < 10; i++) {
    pmembers[i] = new string;
  }

}


#+end_src

** The Committee class (copy constructor)
 

#+begin_src C++
// Copy Constructor
#+end_src

 - Committee::Committee(const Committee &original)

 #+begin_src C++
:  pbudget(new float(*(original.pbudget))) // put this line (delegate copying to cc of float)
{
  // OR these 2 lines (i.e. copy manually)
  // pbudget = new float;
  // *pbudget = *(original.pbudget);

  // OR this one line (again, copy manually)
  // pbudget = new float(*(original.pbudget));

  for (int i = 0; i < 10; i++) {
    pmembers[i] = new string(*(original.pmembers[i]));
  }
}


 #+end_src

** The Committee class (destructor)
 

#+begin_src C++
// Destructor
#+end_src

 - Committee::~Committee()

 #+begin_src C++
    {
      // optional for tracing execution:
      // cout << "Destructor for Committee class" << endl;

      delete pbudget;
      for (int i = 0; i < 10; i++)
        {
          delete pmembers[i];

          // optional for tracing execution:
          // cout << "Deleting array... " << 10 - i << endl;
        }
    }

 #+end_src

** The Committee class (assignment operator)
 

#+begin_src C++
Committee &Committee::operator=(const Committee &original) {
  if (&original != this) {
    // from destructor
    delete pbudget;
    for (int i = 0; i < 10; i++)
      delete pmembers[i];

    // no base class from which to call operator

    // from copy constructor
    pbudget = new float(*(original.pbudget));
    for (int i = 0; i < 10; i++)
      pmembers[i] = new string(*(original.pmembers[i]));
  }
  return *this;
}


#+end_src

** New C++ features to support canonical classes
 

#+begin_src C++
Class A {
  A() = default; // default constructor has default implementation (i.e. does nothing)
  A(const A &original) = default; // copy const. has default impl. (i.e. shallow copies)
  ~A() = default; // destructor has default implementation (i.e. does nothing)
  A &operator=(const A &other) = default; // shallow copy again
  ...
};

// tells compiler that no implementation is desired (rarely a good idea)
Class B{
  B() = delete; // e.g., prevents arrays from being declared
  B(const B &original) = delete; // prevent instances from being passed by value
  ~B() = delete; // prevents instances from being deallocated (can't use delete on B)
  B &operator=(const B &other) = delete; // can't use assignment operator
  ...
};


#+end_src

* Linked lists: Barebones Version :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides015-list.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 

*** Motivation
 
 - Want to allocate memory on demand, but only 1 node at a time 
 - Idea: dynamically allocate only a single node when requested
 - problem: but then we will need an arbitrary number of static (i.e. allocated at compile-time) pointers to handle these -- back to square one!
 - one solution: why not use just 1 static pointer to dynamically allocate the first node, but rather than allocating just for the data, allocate enough space for a compound node structure consisting of the data as well as a pointer to some potential next node 
 - i.e. let's change the definition of a node
 - if the next node does not exist, indicate this by assigning the pointer to null pointer
 - This allows us to gradually develop a linked data structure that can dynamically grow and shrink as needed
 
 
 
*** Node definition
 

#+begin_src C++
struct Node{
  int data;       // the actual data
  Node *next; // pointer to potential next node
};

// We only need 1 pointer to handle this linked list
// It points to the first node of the list

Node *head; // let's make it global for now (can be generalized if needed)
// Initially, there are no nodes, i.e. the list is empty

head = nullptr;

#+end_src

*** Adding a new node to the list
 

#+begin_src C++
void insert(int data){

  Node *temp = head;

  if(temp == nullptr){
    temp = new Node;
    temp->data = data;
    temp->next = nullptr;
    head = temp;
  }



  else{
    while(temp->next != nullptr)
      temp = temp->next;
    temp->next = new Node;
    temp = temp->next;
    temp->data = data;
    temp->next = nullptr;
  }

} // end insert

#+end_src

*** Adding a new node to the list
 

#+begin_src C++
void insertS(int data){

  Node *curr = head;
  Node *prev = nullptr;

  while(curr!=nullptr && curr->data<data){
    prev = curr;
    curr = curr->next;
  }




  if(prev == nullptr){
    prev = new Node;
    prev->data = data;
    prev->next = curr;
    head = prev;
  }
  else{
    prev->next = new Node;
    prev = prev->next;
    prev->data = data;
    prev->next = curr;
  }
} // end insertS

#+end_src

*** Traversing the list
 

#+begin_src C++
bool isEmpty(){
  return head == nullptr;
}


void print(){
  Node *temp = head;
  while(temp != nullptr){
    cout << temp->data <<" ";
    temp = temp->next;
  }
}


int count() {
  Node *temp = head;
  int ctr=0;
  while(temp != nullptr){
    ctr++;
    temp = temp->next;
  }
  return ctr;
}

#+end_src

*** Deleting the entire list
 

#+begin_src C++
void deleteLinkedList(){

  Node *current = head, *previous = nullptr;

  while(current != nullptr){
    previous = current;
    current = current->next;
    delete previous;
  }

  head = nullptr;

}

#+end_src

*** Removing a node
 

#+begin_src C++
void remove(int x){
  Node *prev = nullptr;
  Node *curr = head;

  if(isEmpty())
    return;
  while(curr != nullptr){
    if(curr->data == x)
      break;
    else{
      prev = curr;
      curr = curr->next;
    }
  } // end while
    // found: 1st node needs removing
  if(prev == nullptr){
    Node *temp = head;
    head = head->next;
    delete temp;
  }

  // found: curr needs removing
  if(curr != nullptr && prev != nullptr){
    prev->next = curr->next;
    delete curr;
  }

} // end remove

#+end_src

*** Testing it all out
 

#+begin_src C++
int main() {

  insert(5);
  insert(6);
  insert(7);

  // try out every possibility
  remove(8); // 5, 7, empty list

  insert(3);

  print();

  cout << "\nCount=" << count(); cout << "\n";

  deleteLinkedList();

  cout << "\nCount=" << count(); cout << "\n";

  return 0;
}

#+end_src

* Multisets with Linked Lists :noexport:
:PROPERTIES:
:EXPORT_FILE_NAME: pdf/slides016-multiset.pdf
:END:
#+beamer: \beamerdefaultoverlayspecification{<+->}
#+OPTIONS: todo:nil
 
 
 
 - An application: Multiset Revisited
 
*** ADT Multiset
 
 - Domain: items from ItemType
 
 - Structure: arbitrarily many members, possibly with duplicates
 
 - Operations supported:
 - empty: check if a Multiset instance is empty.
 - memberCount: get the number of items in a Multiset instance
 - insert: insert an item of type ItemType into a Multiset instance
 - remove: remove the first occurrence of an item of type ItemType from a Multiset instance
 - member: test if an item of type ItemType is in a Multiset instance
 - print: print the members of a Multiset instance in ascending order
 
*** ADT Multiset
 

#+begin_src C++
// multiset-linkedlist.h
typedef int ItemType;
struct Node {
  ItemType datum;
  Node *pNext;
};

class Multiset {
public:
  // Default constructor
  Multiset();
  // Copy constructor
  Multiset(const Multiset &original);
  // Destructor
  ~Multiset();
  // Assignment operator
  Multiset &operator=(const Multiset &original);
  // Other functions
  bool empty() const;
  unsigned int memberCount() const;
  void insert(ItemType x);
  void remove(ItemType x);
  bool member(ItemType x) const;
  void print() const;
private:
  Node *pHead;
}; // end Multiset



#+end_src

*** Traversing and managing a linked list
 
 - Traversing: 
 

 #+begin_src C++
bool empty() const;
unsigned int memberCount() const;
void print() const;

 #+end_src

 - Managing (both are private helper member functions):
 

 #+begin_src C++
void deleteLL(Node *pHead) const;
Node *duplicateLinkedList(const Node *pOldHead) const;
 
 #+end_src

*** Implementing duplicateLL
 

#+begin_src C++
Node *duplicateLL(const Node *pHead1) const{

  // empty list
  if (pHead1 == nullptr)
    return nullptr;

  // handle the first node separately
  Node *pHead2 = new Node;
  pHead2->data = pHead1->data;

  // Copy the rest of the linked list
  const Node *p1 = pHead1;
  Node           *p2 = pHead2;



  // still Nodes to copy
  while (p1->pNext != nullptr) {
    // make a new Node for our copy
    p2->pNext = new Node;

    // advance both linked lists
    p1 = p1->pNext;
    p2 = p2->pNext;

    // copy the data
    p2->data = p1->data;
  }
  // set the end of the new list to nullptr
  p2->pNext = nullptr;

  return pHead2;
}

#+end_src

*** Constructors and destructors
 

#+begin_src C++
// default constructor
Multiset::Multiset(){
  pHead = nullptr;
}

// copy constructor
Multiset::Multiset(const Multiset &original){
  pHead = duplicateLL(original.pHead);
}

// destructor
Multiset::~Multiset(){
  deleteLL(pHead);
}



#+end_src

*** Assignment operator
 

#+begin_src C++
Multiset &Multiset::operator=(const Multiset &original){
  if (&original != this){
    deleteLL(pHead);
    pHead = duplicateLL(original.pHead);
  }
  return *this;
}


#+end_src

*** Managing a linked list (cont'd)
 
 - Membership checking, Inserting, and removing
 

 #+begin_src C++
bool Multiset::member(ItemType x) const;
void Multiset::insert(ItemType x);
void Multiset::remove(ItemType x);

 #+end_src

 - Helper function used in notes to implement insert, remove, and member
 - essentially returns ``prev''
 

 #+begin_src C++
Node *searchLinkedList(Node *pHead, ItemType x) const;
 
 
 #+end_src

*** Implementing member
 

#+begin_src C++
bool Multiset::member(ItemType x) const {

  Node *pPrev = searchLinkedList(pHead, x);

  if (pPrev != nullptr) // must be the next item, it at all
    return pPrev->pNext != nullptr && pPrev->pNext->data == x;
  else // must be the first item if even exists
    return pHead != nullptr && pHead->data == x;

}
#+end_src



* Emacs Variables (please ignore) :noexport:
Local Variables:
org-latex-packages-alist: nil
org-export-with-tags: nil
End:

* A1 test :noexport:
#+begin_src C++
void mixed(int i1, double d1); // 7A
void mixed(double d1, int i1); // 7B
double r5 = 55.5, r6 = 66.6;
mixed(r5, r6);
#+end_src

#+RESULTS:
