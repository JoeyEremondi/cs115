* Review
 
 
 - Basic program structure, local/global variables, value passing semantics, strings, program dev. process
 
** Hello world!
 

#+begin_src c++
    #include <iostream>
    using namespace std;
 
    int main( ){
      cout << "Hello, World!" << endl;
      return 0;
    }
 
 
 
#+end_src

 - 4 types of control structures: 
 - sequences (see above)
 - conditionals
 - loops
 - function invocations 
 
** Functional abstraction
 

#+begin_src c++
    // Declaration of the triple function
    int triple(int x);
 
    int main( ){
      int answer;
      answer = triple(5);
      cout << answer << endl;
      cout << triple(2) << endl;
      return 0;
    }
 
 
 
    // Definition of the triple function
    int triple(int x) {
  return 3 * x;
    }
 
#+end_src

 - Must declare functions before referencing them
 - use function prototype /header
 - OR declare before 1st use
 
 - Scope of a function = file scope
 
 - Can a function call itself?!
 
** Local and global variables and constants
 

#+begin_src c++
    // Declaration of a global variable
    int g;
 
    // Declaration of a global constant
    const int THREE = 3;
 
    int main( ){
      const int LOC = 29;
      int loc = LOC;
      g = 42;
      cout << g << endl;
      tripleGlobal();
      cout << g << endl;
      return 0;
    }
 
    void tripleGlobal( ){
      // The local var loc is not acc. 
      // The global var g is accessible 
  g = THREE * g;
    }
 
#+end_src

 - Use ``extern to access global variables declared in other files
 
** Conditionals (if-then-else branching)
 

#+begin_src c++
    int max(int a, int b){
      if (a >= b)
        return a;
      else
        return b;
    }
 
 
 
    int main( ){
      cout << max(-1, 2) << endl;
      cout << max(1, -2) << endl;
      return 0;
    }
 
 
#+end_src

** Conditionals (ternary operator cond ? b1 : b2)
 
 - Compare the following:
 

#+begin_src c++
    int max(int a, int b){
      if (a >= b)
        return a;
      else
        return b;
    }
 
    int max(int a, int b) {
      return (a >= b) ? a : b;
    }
 
#+end_src

 - Can be nested:
 

#+begin_src c++
    int inRange(int num, int low, int high) {
     if(num>=low)
    if(num<=high)
    return 1;
    return 0;
    }
 
#+end_src

 - Note: could have used a compound conditional statement instead 
 
** Conditionals (else-if and switch cases)
 
 - Can have multiple branches:
 

#+begin_src c++
    int sign(int a){
      if (a > 0)
        return 1;
      else if (a < 0)
        return -1;
      else
        return 0;
    }
 
 
 
#+end_src

 - Switch cases?
 

#+begin_src c++
    switch (month){
          case 1: case 2: case 3: case 4:
             cout << "Winter";
             break;                                        
          case 5: case 6: case 7: case 8:
             break;      
          case 9: case 10: case 11: case 12:    
             cout << Fall;
             break;                      
          default:
          cout << "What are we smoking today?";
     }
 
#+end_src

** Repetition structures (loops)
 
 - Want to compute: 
 - f(n) = 1 + 2 + 3 + ... + n
 

#+begin_src c++
    unsigned int triangular(unsigned int n){
      unsigned int result = 0;
      for (unsigned int i = 1; i <= n; i++){
        result += i;
      }
      return result;
    }
 
#+end_src

 - Order of execution?
 
 - Can have an empty body!
 
 
 
** Repetition structures (loops)
 

#+begin_src c++
    const unsigned int BASE = 10;
 
    unsigned int sumOfDigits(unsigned int m){
    unsigned int sum = 0;
    while (m != 0) {
    unsigned int digit;
    digit = m % BASE;
    sum = sum + digit;
    m = m / BASE;
    }
      return sum;
    }
#+end_src

 - Trace it!
 
 - More readable than for loops
 
 - Do-while executes at least once
 
 - Loops can be nested
 
** Value passing semantics
 
 - Call by value (arguments evaluated)
 

#+begin_src c++
    void doubleV(int a){
  a = a*2;
    }
 
    int main( ){
      int a = 2;
      doubleV(a+a);
      cout << a << endl;
 
      return 0;
    }
#+end_src

 - Call by reference (can only send vars)
 

#+begin_src c++
    void doubleR(int &a){
  a = a*2;
    }
 
    int main() {
      int a = 4;
      doubleR(a);
      cout << a << endl;
 
      return 0;
    }
 
 
#+end_src

** Value passing semantics
 
 - Call by address (arguments evaluated)
 

#+begin_src c++
void doubleP(int *a){
  *a = (*a)*2;
    }
 
    int main( ){
      int a = 4;
      doubleP(&a);
      cout << a << endl;
 
      return 0;
    }
#+end_src

 - Call by reference (can only send vars)
 

#+begin_src c++
    void doubleR(int &a){
  a = a*2;
    }
 
    int main() {
      int a = 4;
      doubleR(a);
      cout << a << endl;
 
      return 0;
    }
 
 
#+end_src

** Side effects
 
 - Any computational effects of a function other than the generation of a value to be returned
 - those that persist
 - e.g., printing stuff using cout, changing a global variable, changing a local variable via call by reference/pointer, etc.  
 
** Strings
 
 - C++ libraries provide string facilities
 

#+begin_src c++
    #include <string>
 
    int main( ){
      string h = "hello";
      string msg = h +   + w;
 
      cout << msg << endl;  
 
      return 0;
    }
    string s = "hello world";
    for (int i = 0; i < s.length(); i++)
    cout << s[i] << endl;
 
#+end_src

 - Characters are integer values
 

#+begin_src c++
    char charToUpper(char c){
    if (a <= c && c <= z)
    return c - a + A;
    else
    return c;
    }
 
#+end_src

** Strings
 
 - Passing a parameter by reference can be more efficient than passing by value for very large strings
 - But not safe as modifying the passed string also modifies the original one
 - Solution: pass by constant reference 
 
 - For example: 

#+begin_src c++
    string capitalize(const string &s);
 
 
#+end_src

 - Occasionally, you may want to return a value by constant reference (meh!)
 
 - const string &chooseFirst(const string &s1, const string &s2)

#+begin_src c++
    {
    if (s1 < s2)
    return s1;
    else
    return s2;
    }
 
 
#+end_src

** Strings
 
 - string &chooseFirst(string &s1, string &s2)

#+begin_src c++
    {
    if (s1 < s2)
    return s1;
    else
    return s2;
    }
 
 
#+end_src

 - chooseFirst( ) returns reference to lexicographically smaller string
 
 - main( ) prints PQR! since s1=PQR!
 - int main( )

#+begin_src c++
    {
    string s2 = XYZ!;
 
    chooseFirst(s1, s2) = "PQR!";
 
    cout << s1;
 
    return 0;
    }
 
#+end_src

** Modular vs. Application programs (115 vs. 110)
 
 - Top-down design is the process of repeatedly decomposing a complicated problem into smaller, more manageable subproblems
 - each can be implemented independently
 - e.g., decomposing a function into many smaller ones
 
 - cf. the bottom-up approach
 - the program development process can be seen as a process of building reusable tools, and then using those tools to build even more powerful tools, eventually leading to a solution to the original problem
 
 - Reuse reduces the overhead of solving a recurring problem over and over again, saves us from redoing testing and documentation for similar code, and in general improves the comprehensibility of source code
 

#+begin_src c++
    Code structured into modules; separates interface from implementation 
 
#+end_src

** Standard input and output
 
 - Can redirect standard input and output from and to files resp.
 
 - myProg < inFile > outFile
 
 - Can pipe the standard output of a program to the standard input of another
 
 - myProg1 | myProg2
 
 
 - See notes for how 
 - getline(cin, <string>) and cin.get(<char>) can be used to read input from a file
 
 
 
** Misc
 

#+begin_src c++
    Separate (unrelated) functions in different files; compile separately using -c command, and link together
 
#+end_src

 - g++ -c main.cpp
 - g++ -c my_util.cpp
 - g++ -o prog.out main.o my_util.o
 
 - Collect all function prototypes together in a header file and include it in main.cpp
 

#+begin_src c++
    #include my_util.h
    #pragma once preprocessor
 
#+end_src

 - Assertions (debugging aid)
 

#+begin_src c++
    #include <cassert>
    ...
    assert (n>0); //prog. Terminates if not
 
 
 
 
#+end_src

* Arrays
 
 
 - One, two, and multi-dimensional arrays
 
** Motivation
 

#+begin_src c++
      int value0;
      int value1;
      int value2;
#+end_src

 -    .
 -    .
 -    .

#+begin_src c++
      int value999;
 
      cin >> value0;
      cin >> value1;
      cin >> value2;
#+end_src

 -    .
 -    .
 -    .

#+begin_src c++
      cin >> value999;
 
      cout << value999 << endl;
      cout << value998 << endl;
      cout << value997 << endl;
#+end_src

 -    .
 -    .
 -    .

#+begin_src c++
      cout << value0 << endl;
 
 
#+end_src

 
 - Tedious, not scalable, and error prone
 
 - Solution: use aggregate data type
   + homogenous components 
   + indexing support 
   + constant time access 
   + random access 
 
 

#+begin_src c++
     int a[120000];    // Array declaration
 
      for (int i = 0; i < 120000; i++) 
      cin >> a[i];    // Array access             
      for (int i = 119999; i >= 0; i--)
      cout << a[i] << endl;
 
#+end_src

** Simple arrays
 
 

#+begin_src c++
      const int N = 120000;
      int a[N];    // Array declaration
 
      for (int i = 0; i < N; i++) 
      cin >> a[i];    // Array access             
      for (int i = N-1; i >= 0; i--)
      cout << a[i] << endl;
 
 
#+end_src

 - Array size must be a constant expression
 
 - Easy to change size: just update N (the rest of the program remains intact)
 
** Passing arrays as arguments
 

#+begin_src c++
    int sumArray(int a[], unsigned int n) // Array argument
    {   
      int sum = 0;
      for (int i = 0; i < n; i++)
        sum += a[i];
      return sum;
    }
 
 
    int main()
    {
    // Array initialization
      int a[] = { 3, 24, -88, 17, -1 };  
      cout << sumArray(a, 5) << endl;
    }
 
#+end_src

 - Array size can be left unspecified in array initialization syntax
 
** Passing arrays as arguments
 
 - Array arguments are always automatically passed by reference 
 - no special notation is require
 

#+begin_src c++
    // int sumArray(int& a[], unsigned int n) - INCORRECT
    int sumArray(int a[], unsigned int n)    // CORRECT
    {
      ...
    }
#+end_src

 - Works for arrays of all sizes (size is passed as a separate argument)
 - Interface not safe: can modify the content of A
 
** Passing arrays as arguments
 

#+begin_src c++
    int sumArray(int a[], unsigned int n)    // not safe, sumArray can modify A!
 
#+end_src

 - Use the following instead:
 - int sumArray(const int a[], unsigned int n)
 
 - How to figure out array size when passing n if the size was left unspecified when declaring it?
 - use sizeof function: 

#+begin_src c++
    int a[] = {1,2,6,3,8};
    int x = sumArray(a, sizeof(a) / sizeof(int));
 
#+end_src

** Play time
 

#+begin_src c++
    bool arrayIsSorted(const int a[], unsigned int n){
    for (int i = 0; i < n-1; i++){
      if (a[i] > a[i+1])
      return false;
     }
     return true;
    }
 
 
#+end_src

** Play time
 

#+begin_src c++
    void swap(int &a, int &b) {
    int tmp = a;
    a = b;
    b = tmp;
    } 
    // below a[] is not a constant as want to produce side-effect
    void reverseArray(int a[], unsigned int n) {
    for (int i = 0; i < n/2; i++)
      swap(a[i], a[n - i - 1]);
    }
 
#+end_src

** Processing subarrays
 

#+begin_src c++
    // pos   : index of the first component in the subarray
    // count: total number of components in the subarray
    int sumSubarray(const int a[], unsigned int pos, unsigned int count){
    int sum = 0;
    for (int i = pos; i < pos + count; I++)
    sum += a[i];
 
      return sum;
    }
 
#+end_src

** Processing subarrays
 

#+begin_src c++
    // begin: index of first component in the subarray
    // end   : index of the last component in the subarray
    int sumSubarray(const int a[], unsigned int begin, unsigned int end){
    assert(begin <= end);
    int sum = 0;
    for (int i = begin; i <= end; I++)
    sum += a[I];
 
    return sum;
    }
 
#+end_src

** Subtleties
 
 - C++ does not check if array indices are within bound 
 - Array Copying

#+begin_src c++
    a = b // invalid
#+end_src

 - copy cell by cell: 

#+begin_src c++
    a[6]=b[9] // works!
#+end_src

 - Array Comparison

#+begin_src c++
    if(a == b) // invalid
#+end_src

 - compare each pair of cells at a time
 - No need to return array as function output, uses call by reference anyway!
 
** Two dimensional arrays
 
 - Want to store quantity of different products sold in a store
 - but for multiple locations/regions 
 
 - Conceptually can store as a matrix, where rows represent different locations and columns represent different products
 - sales[2][1] are the total number of items sold for location 2 and product 1
 - recall item n is the (n+1)-th item as index starts from 0!
 
** Two dimensional arrays
 

#+begin_src c++
    const unsigned int NUM_OF_REGIONS = 4;
    const unsigned int NUM_OF_PRODUCTS = 3;
 
    unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS];
 
#+end_src

 - To access sales figure for first product in second region, use: 

#+begin_src c++
    sales[1][0] // recall, indices start from 0 
 
#+end_src

 - e.g., want to set sales figure for first product in second region to 500 

#+begin_src c++
    sales[1][0] = 500;
 
#+end_src

** Two dimensional arrays
 

#+begin_src c++
    // Read input stream
     for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
    for (unsigned int product = 0; product < NUM_OF_PRODUCTS; product++)
    cin >> sales[region][product];
 
    unsigned int total_sales = 0; // total sales for a particular product (product 0)
 
    for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
    total_sales += sales[region][0]; // add up sales from all regions for product 0
 
#+end_src

   + Can you compute total sales from region 1? 
 
** Two dimensional arrays
 
 - unsigned int sumProductSales(unsigned int 

#+begin_src c++
    sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS], unsigned int product){
    unsigned int total_sales = 0;
    for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
    total_sales += sales[region][product];
 
    return total_sales;
    }
 
#+end_src

 - Can you implement a safer interface? (see slide 7)
 
 - As usual, can leave size of first dimension unspecified, e.g. int F(int arr[ ][SIZE]) 
 - but not the second one (why?)
 
** Making things more modular
 

#+begin_src c++
    // Implement a function that returns the value of one element from the sales array
#+end_src

 - unsigned int getSales(const unsigned int 

#+begin_src c++
    sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS], unsigned int r, unsigned int p){
    return sales[r][p];
    }
    // Implement a function that sets the value of one element from the sales array
#+end_src

 - void setSales(unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS],

#+begin_src c++
    unsigned int r, unsigned int p, unsigned int v){
    sales[r][p] = v;
    }
 
#+end_src

** Using typedef
 

#+begin_src c++
    // too lazy to write long types? Use typedef instead!
 
    typedef unsigned int Sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS];
 
    unsigned int sumSales(const Sales sales){
    ...
    }
 
 
 
 
 
#+end_src

** Simulating Two-dimensional Arrays by One-dimensional Ones
 

#+begin_src c++
    unsigned int sales[NUM_OF_REGIONS][NUM_OF_PRODUCTS];
#+end_src

 - versus

#+begin_src c++
unsigned int _sales[NUM_OF_REGIONS * NUM_OF_PRODUCTS];
 
#+end_src

 - Issue: how to map between these two?
   + row-major vs. column-major order 
e.g. sales[i][j] is the same as _sales[i * NUM_OF_PRODUCTS + j] in row-major 
 
   + Can you write the formula for column-major order? 
 
** Simulating Two-dimensional Arrays by One-dimensional Ones
 

#+begin_src c++
    unsigned int totalSales = 0;
 
    for (unsigned int region = 0; region < NUM_OF_REGIONS; region++)
    for (unsigned int product = 0; product < NUM_OF_PRODUCTS; product++)
totalSales += _sales[region * NUM_OF_PRODUCTS + product];
 
 
#+end_src

** Multi-dimensional Arrays
 

#+begin_src c++
    const unsigned int NUM_YEARS = 2;
    const unsigned int NUM_REGIONS = 4;	
    const unsigned int NUM_PRODUCTS = 3;
 
    typedef unsigned int Sales[NUM_YEARS][NUM_REGIONS][NUM_PRODUCTS];
 
    unsigned int total_sales = 0;
    for (unsigned int year = 0; year < NUM_YEARS; year++)
    for (unsigned int region = 0; region < NUM_REGIONS; region++)
    for (unsigned int product = 0; product < NUM_PRODUCTS; product++)
    total_sales += sales[year][region][product];
 
#+end_src

** Multi-dimensional Arrays
 
 
 - Sales[year][region][product]
 
 - vs.
 
_Sales[(year * NUM_REGS * NUM_PRODS) + (region * NUM_OF_PRODS) + product]
 
** Multi-dimensional Arrays
 
 - In general for a d-dimensional array with dimensions S_1, S_2, ..., S_d, the element at 
 
 - Item[n_1][n_2]...[n_d]
 
 - can be represented as a single dimensional array with the following index
 

#+begin_src c++
_Item[n_d + S_d * (n_{d-1} + S_{d-1} * (n_{d-2} + S_{d-2} * (...+S_2*n_1) ... ))] 
 
#+end_src

* Records
 
 
 - Structs and unions
 
** Motivation
 
 - Data in collection is heterogenous 
 
 
 
 
 
 
 
 
 
 - Solution using arrays:

#+begin_src c++
    string titles[N];
    string authors[N];
    string publishers[N];
    unsigned int publishingYears[N];
    string callNumbers[N];
    double Price[N];
 
#+end_src

 - Poor choice of interface!
 - (many arguments to pass for functions)
 
** Motivation
 
 - Data can be heterogenous 
 - Define:

#+begin_src c++
    struct CatalogEntry {
        string title;
        string author;
        string publisher;
        unsigned int publishingYear;
        string callNumber;
    };
#+end_src

 - Only 1 argument needs to be passed
 - Declare:

#+begin_src c++
    struct CatalogEntry c; 
    or CatalogEntry c;
 
#+end_src

 - Initialize:

#+begin_src c++
    c.title = "Peter Pan";
    c.author = "J. M. Barrie";
    c.publisher = "Scribner";
    c.publishingYear = 1980;
    c.callNumber = "B2754 1980";
 
#+end_src

** Initializing and copying a record
 
 - As with arrays 
 
 - CatalogEntry c = 

#+begin_src c++
    {
#+end_src

 -   "Peter Pan",
 -   "J. M. Barrie",
 -   "Scribner",
 -   1980,
 -   "B2754 1980"

#+begin_src c++
    };
 
#+end_src

 - Copying a record:

#+begin_src c++
    // initialization list
    CatalogEntry c = { ... }; 
 
    // initialization by copying
    CatalogEntry c1 = c;    
 
    // default initialization  
    CatalogEntry c2;   
    // assignment operator       
    c2 = c;                   
 
#+end_src

** Functions operating on records
 

#+begin_src c++
    void printCatalogEntry(CatalogEntry c){
         cout << "Title: " << c.title << endl;
         cout << "Author: " << c.author << endl;
         cout << "Publisher: " << c.publisher << endl;
         cout << "Publishing Year: " << c.publishingYear << endl;
         cout << "Call Number: " << c.callNumber << endl;
    }  
 
#+end_src

 - As usual, by default arguments are passed by value (call by value)
 
 
** Functions operating on records
 
 - For efficiency, call by reference is also supported
 

#+begin_src c++
    void printCatalogEntry(const CatalogEntry &c){
         cout << "Title: " << c.title << endl;
         cout << "Author: " << c.author << endl;
         cout << "Publisher: " << c.publisher << endl;
         cout << "Publishing Year: " << c.publishingYear << endl;
         cout << "Call Number: " << c.callNumber << endl;
    }  
 
 
 
#+end_src

** Equality checking
 

#+begin_src c++
    if (c1 == c2)  // invalid
 
#+end_src

 - As in the case for arrays, must do this each field at a time

#+begin_src c++
    bool CatalogEntryEquals(const CatalogEntry& c1, const CatalogEntry& c2){
#+end_src

 -   return
 -       c1.title == c2.title &&
 -       c1.author == c2.author &&
 -       c1.publisher == c2.publisher && 
 -       c1.publishingYear == c2.publishingYear &&

#+begin_src c++
          c1.callNumber == c2.callNumber;
    }
 
 
 
#+end_src

** Complex record data structures
 

#+begin_src c++
    CatalogEntry A[3];
 
#+end_src

 - CatalogEntry A[] = 

#+begin_src c++
    {
    {"Peter Pan",
        "J. M. Barrie",//
        "Scribner",//
        1980,//
        "B2754 1980"},
 
 
 
    {"C++ Primer",
         "Stanley B. Lippman",//
         "Addison-Wesley",//
         1998,//
 
       {"Anatomy of LISP",
         "John Allen",//
         "McGraw-Hill",//
         1978,//
         "QA 76.73 L23A44"}
     };
 
 
 
 
 
 
#+end_src

** Practise!
 
 - See the very first announcement in UR Courses
 - Try the exercises there
   + declare a C++ struct to represent a point in the Cartesian coordinate system 
   + declare a C++ struct to represent a hexagon 
   + declare a C++ struct to represent a circle 
 
** Complex record data structures
 

#+begin_src c++
    const int MAX_NAMES = 100;
 
    struct FullName {
          string name_component[MAX_NAMES];
          int name_count;
     };
 
 
 
 
 
 
 
#+end_src

** Complex record data structures
 

#+begin_src c++
    const int SCREEN_HEIGHT = 768, SCREEN_WIDTH = 1024;
     struct Screen{
    char screen_array[SCREEN_HEIGHT][SCREEN_WIDTH];
     };
 
    ...
 
    Screen my_screen;
    for (int i = 0; i < SCREEN_HEIGHT; i++){
     }
 
 
 
 
 
 
 
 
#+end_src

** Complex record data structures
 

#+begin_src c++
    struct str1 {
    int a[2];
    int b;
    }; 
 
    void func1(str1 A[ ]){
    A[0].a[0] = 10;
    A[0].a[1] = 20;
    A[0].b = 30;
    }
 
    int main( ) {
    str1 A[ ] = {{{1,0},2}, {{3,0},4},{{0,0},9}};
    func1(A);
 
    std::cout << A[0].b<<n;
    std::cout << A[0].a[1]<<n;
    }
 
#+end_src

 - What will be the output?
 
** Enumerations
 
 - User-defined data type that consists of integral constants
 

#+begin_src c++
    enum day {
      Friday = 99,//
      Saturday,//
      Sunday = 90,//
      ...,
      Thursday //
    };
 
    day d;
    d = Thursday;
 
    if (d == Saturday || d == Sunday)
    cout << Enjoy the weekend! ;
 
    cout << d+1 ;
 
#+end_src

 - What will be the output?
 
** Variant records
 
 - Multiple component fields can be defined
 - At most one field can be in use at one time (fields share the same memory)
 

#+begin_src c++
    union Coordinates {
      int a, //
      double b, //
      char c //
    };
 
    Coordinates x;
 
    x.a = 5;
    cout << x.a;         // works, prints 5      
 
    x.b = 416.905;     // destroys the value of x.a
    cout << x.a;         // invalid!
    cout << x.b;         // invalid!
    cout << x.c;         // works, prints p
 
#+end_src

** Example
 

#+begin_src c++
    enum CatalogEntryType {
      BookEntry, //
      DVDEntry //
    };
 
    struct BookSpecificInfo {
      unsigned int pages;
    };
 
 
 
    struct DVDSpecificInfo {
      unsigned int discs;
      unsigned int minutes;
    };
 
    union CatalogEntryVariantPart {
      BookSpecificInfo book;
      DVDSpecificInfo dvd;
    };
 
 
#+end_src

 

#+begin_src c++
    struct CatalogEntry {
      string title;
      string author;
      string publisher;
      unsigned int publishingYear;
      string callNumber;
      CatalogEntryType tag;
      CatalogEntryVariantPart variant;
    };
 
 
#+end_src

 

#+begin_src c++
    void printCatalogEntry(const CatalogEntry& c) {
      cout << "Title: " << c.title << endl;
      ...
      cout << "Call Number: " << c.callNumber << endl;
      switch (c.tag) {
      case BookEntry:
        cout << "Pages: " << c.variant.book.pages << endl;
        break;
      case DVDEntry:
        cout << "Discs: " << c.variant.dvd.discs << endl;
        cout << "Minutes: " << c.variant.dvd.minutes << endl;
        break;
      }
    } 
 
 
#+end_src

** Anonymous declaration of records and variant-records
 
 - Earlier:

#+begin_src c++
    union CatalogEntryVariantPart {
      BookSpecificInfo book;
      DVDSpecificInfo dvd;
    };
 
#+end_src

 - Could have actually declared them in-line:

#+begin_src c++
    union CatalogEntryVariantPart {
    struct BookSpecificInfo { unsigned int pages; } book;
    struct DVDSpecificInfo { unsigned int discs, minutes; } dvd;
    };
 
#+end_src

** Anonymous declaration of records and variant-records
 
 - Can also anonymize:
 

#+begin_src c++
    union CatalogEntryVariantPart {
    struct { unsigned int pages; } book;
    struct { unsigned int discs, minutes; } dvd;
    };
 
 
 
#+end_src

** Anonymous declaration of records and variant-records
 
 - In fact, we could have done the same with the union
 

#+begin_src c++
    struct CatalogEntry {
    string title;
    string author;
    string publisher;
    unsigned int publishingYear;
    string callNumber;
    CatalogEntryType tag;
    union {
    struct { unsigned int pages; } book;
    struct { unsigned int discs, minutes; } dvd;
    } variant;
    };
 
 
#+end_src

* Program Organization Principles
 
 
 
 - Terminology concerning program organization, interface vs. implementation, data encapsulation, information hiding, modularity, layering, design by contract, abstract data types 
 
** Terminology concerning program organization
 
 - is a design principle for separating a computer program into distinct sections such that each section addresses a separate concern
 - concern = a set of information that affects code 
 - can be realized via layering and modularity
 
 - Layering: use separate layers in the software, each of which addresses a different concern (e.g., presentation layer, business logic layer, data access layer, etc.)
 
 - break system into parts and to hide the complexity of each part behind an abstraction and interface
 
** Terminology concerning program organization
 
 - Why bother?
 - Simplifies development and maintenance of computer programs
 - Promote software reuse 
 - Modules can be developed and updated independently (can improve on one section of code without changing other sections)
 
 - How to realize modularity?
   + procedural programming: via functions and top-down design 
 - OOP: via classes and objects 
 
** Terminology concerning program organization
 
 - Refactoring is to rewrite code in order to improve its readability, reusability, or structure without affecting its meaning or behaviour
 - perhaps older version was poorly written due to time constraints etc.

#+begin_src c++
    e.g., replace 416 with the constant GTA_CODE1, replace long if-then-else branches with switch/case statements, divide overly complex implementation into smaller functions, replace with efficient code, etc.
 
#+end_src

** Terminology concerning program organization
 
 - Each level represents an increasingly detailed model of the software system and its processes
 - at each level, the model is described using concepts appropriate to a certain domain 
 - each higher, more abstract level builds on a lower, less abstract level
 
 - To understand levels of abstraction better, see optional slides on Layering
 
** Modular programming
 
 - Modular programming is a method of developing software where each section of code is a module with a carefully specified interface 
 - interface makes the purpose of your code clear
 - client software can focus on the interface (and ignore its implementation)
 
 - A crucial aspect of modular programming is mentally separating the interface from the implementation
 - we will specify the interfaces in .h files (as well-documented prototypes) 
 - we will specify the implementation in .cpp files (primarily as functions)
 - some functions and variables are not (directly) accessible!
 
** Separating interface and implementation
 
 - via data encapsulation
 - hide variables describing state of the module inside the module
 - (static variables/functions and namespaces)
 
 - by defining new abstract data types (ADT) using records and classes
 
** The static keyword
 

#+begin_src c++
    // whatever.cpp
 
    static int foo = 5;
    int bar = 6;
 
    static void doh(int var1) {
    // do something
    }
 
    void yay(char c){
    // do something 
    }
    // main.cpp
 
    int main ( ){
 
    extern int foo; // invalid
    extern int bar; // works!
 
    doh(13); // invalid
 
    }
 
#+end_src

** The static keyword
 

#+begin_src c++
    void fun(int var1) {
    int x1=0;
    x1+=var1;
    cout << x1;
    }
 
    void funS(int var1) {
    static int x2=0;
    x2+=var1;
    cout << x2;
    }
 
    int main ( ){
 
    fun(5);
    fun(5);
    fun(7);
 
    funS(5);
    funS(5);
    funS(7);
 
    }
 
#+end_src

** Namespaces
 

#+begin_src c++
    // myProg.h
 
    #pragma once
 
    namespace myNSpace{
        void Foo();
        int Bar();
    }
 
 
 
 
    #include "myProg.h"
    using namespace myNSpace;
 
    // use fully-qualified name here
    void myNSpace::Foo(){
       // no qualification needed for Bar()
       Bar();
    }
 
    int ContosoDataServer::Bar(){
    return 0;
    }
 
#+end_src

** Anonymous namespaces
 

#+begin_src c++
    // myProg.h
 
    #pragma once
 
    namespace {
        float foo;
        double pi(){
     return 3.141592653;
     }
    }
 
    char bar;
    // myProg.cpp
 
    #include "myProg.h"
 
    int main(){
    foo = 2.718281828; // invalid!
    double y = pi();        // invalid!
    char c = bar;           // works 
 
    return 0;
    }
 
#+end_src

 
 - Can declare the same namespace over multiple sections
 - Have to be careful about usage of identifiers
 
 - Can have nested namespaces, inline namespaces, namespace aliases, etc.
 
 - Also check out the global namespace
 
** Data encapsulation
 
 - to place a barrier around the variables that represent the internal state of a software component so that these variables cannot be accessed directly by client code
 - can be achieved via static variables 
 - (restricts variable/function scope to file)
 - hides implementation details
 - clients are forced to use interface to access data
 - similar effects can be achieved using namespaces 
 
** Separating interface and implementation
 
 - Start by specifying the interface of the module
 

#+begin_src c++
    // initializeCounter
    //
    // Purpose: Initialize the bounded counter module.
    // Parameter(s):
    //  <1> value1: Initial value for the counter expressed as an unsigned integer.
    //  <2> upper1: Upper bound for counter value expressed as an unsigned integer.
    // Precondition(s): value1 < upper1
    // Returns: N/A
    // Side effect: The counter is initialized, with value1 as the current counter value, and upper1 as the 
    // upper bound of counter values.
 
#+end_src

** Separating interface and implementation
 

#+begin_src c++
    // getCounterValue
    //
    // Purpose: Retrieve the current value of
    // the counter.
    // Parameter(s): N/A
    // Precondition(s): N/A
    // Returns: The unsigned integer value of
    // the counter.
    // Side effect: N/A
 
 
    // incrementCounter
    //
    // Purpose: Increment the value of the 
    // counter.
    // Parameter(s): N/A
    // Precondition(s): N/A
    // Returns: N/A
    // Side effect: The counter value is 
    // incremented by one. If the incremented 
    // value reaches the upper bound, then the 
    // counter value is reset to zero.
 
#+end_src

** Separating interface and implementation
 

#+begin_src c++
    // encapsulated_counter.h
    //
    // This module provides ...
    // Data encapsulation is used to
    // protect the state of the bounded
    // counter from manipulation by client
    // code, except via the functions in
    // the interface.
 
 
    #pragma once
    //initializeCounter 
    //...
    void initializeCounter(unsigned int value1, unsigned int upper1);
    // getCounterValue
    //...
    unsigned int getCounterValue();
    // incrementCounter
    //...
    void incrementCounter();
 
#+end_src

** Separating interface and implementation
 

#+begin_src c++
    #include <iostream>
    using namespace std;
    #include "encapsulated_counter.h"
 
    int main() {
      initializeCounter(0, 3);
      cout << getCounterValue() << endl;
      incrementCounter();
      cout << getCounterValue() << endl;
 
      incrementCounter();
      incrementCounter();
      cout << getCounterValue() << endl;
      return 0;
    }
 
#+end_src

 - Output: 
 - 0
 - 1
 - 0
 
** Separating interface and implementation
 

#+begin_src c++
    // encapsulated_counter.cpp
    //
    static unsigned int counter_value;
    static unsigned int counter_upper;
 
    void initializeCounter(unsigned int value1, unsigned int upper1) {
      counter_value = value1;
      counter_upper = upper1;
    }
 
    unsigned int getCounterValue(){
      return counter_value;
    }
    void incrementCounter(){
      ++counter_value;
      if (counter_value == counter_upper)
        counter_value = 0;
    }
#+end_src

 - Note the data encapsulation, the opaqueness of the module, and the separation btw interface and implementation
 
** Design by contract
 
 - Allows for clean division of labour
 - Specifies the usage convention for a module is captured in a contract between the supplier (the developer of the module) and the client (the user of the module)
 - Protects all parties by specifying
 - Usually specified using
 - preconditions
 - postconditions
 - invariants 
 
** Design by contract (example)
 

#+begin_src c++
    // initializeCounter
    //
    // Purpose: Initialize the bounded counter module.
    // Parameter(s):
    //  <1> value1: Initial value for the counter expressed as an unsigned integer.
    //  <2> upper1: Upper bound for counter value expressed as an unsigned integer.
    // Precondition(s):
    //  <1>: value1 < upper1
    // Returns: N/A
    // Side Effect: The global counter is initialized, with value1 as 
    //              the current counter value, and upper1 as the upper 
    //              bound of counter values.
 
#+end_src

** Design by contract (example)
 

#+begin_src c++
    // encapsulated_counter.cpp
    #include <cassert>
 
    void initializeCounter(unsigned int value1, unsigned int upper1){
    assert(value1 < upper1);  // encapsulated_counter.cpp
    counter_value = value1;
    counter_upper = upper1;
    }
 
#+end_src

** Design by contract (example)
 

#+begin_src c++
    // initializeCounter
    //
    // Module invariant: Current counter value is always strictly less than the upper 
    // bound.
    //
 
    static bool isInvariantTrue(){
      return counter_value < counter_upper;
    }
 
 
 
#+end_src

** Design by contract (example)
 

#+begin_src c++
    void initializeCounter(unsigned int value1, unsigned int upper1){
      assert(value1 < upper1);
      counter_value = value1;
      counter_upper = upper1;
      assert(isInvariantTrue());
    }
    unsigned int getCounterValue(){
      assert(isInvariantTrue());
      return counter_value;
    }
    void incrementCounter(){
       assert(isInvariantTrue());
       ++counter_value;
       if (counter_value == counter_upper)
        counter_value = 0;
       assert(isInvariantTrue());
    }
 
#+end_src

** Interface vs. implementation
 
 - Consider designing a timer that represents the accumulated time in [hh:mm:ss] format
 - Internally can be implemented in many ways
 - e.g., only store seconds
 - e.g., store all hours, minutes, and seconds
 - But if interface remains the same, changing implementation does not require changing client code
 
** Abstract data types (ADT)
 
 - Motivation: returning to our example, we want to have multiple counters
 - ADT:  data type defined by its possible values and operations, e.g.: counters

#+begin_src c++
    // counter.h
    //
    // This module defines an abstract data type named Counter.  A counter value is maintained by 
    // each instance of the Counter type. Users may increment or retrieve the value of the counter.
    //
    // Data type invariant: Current value of a counter instance must be strictly smaller than its 
    // upper bound
    struct Counter{
    // ... details to be filled out later
    };
 
#+end_src

** Abstract data types (ADT)
 

#+begin_src c++
    // counterInitialize
    //
    // Purpose: Initialize a counter instance.
    // Parameter(s):
    //  <1> counter: A counter instance to be initialized.
    //  <2> value1: Initial value for the counter specified as an unsigned integer.
    //  <3> upper1: Upper bound for counter value specified as an unsigned integer.
    // Precondition:
    //  <1> value1 < upper1
    // Side Effect: The counter instance is initialized, with value1 as 
    //              the current counter value, and upper1 as the upper 
    //              bound of counter values.
    //
    void counterInitialize(Counter& counter, unsigned int value1, unsigned int upper1);
 
#+end_src

** Abstract data types (ADT)
 

#+begin_src c++
    // counterGetValue
    //
    // Purpose: Retrieve the current value of a 
    // counter instance.
    // Parameter(s):
    //   <1> counter: A counter instance
    // Returns: The unsigned integer value of the 
    // counter instance.
 
    unsigned counterGetValue(const Counter& counter);
 
 
    // counterIncrement
    //
    // Purpose: Increment a given counter 
    // instance.
    // Parameter(s):
    //   <1> counter: counter instance to be
    //    incremented
    // Side Effect: The counter value of the 
    // parameter is incremented by one. If the 
    // incremented value reaches the upper 
    // bound, then the counter value is reset to
    // zero.
    void counterIncrement(Counter& counter);
 
#+end_src

** Abstract data types (ADT)
 

#+begin_src c++
    int main( ){
      Counter c, d;
      counterInitialize(c, 0, 3);
      counterInitialize(d, 0, 10);
      counterIncrement(c);  counterIncrement(c);  counterIncrement(c);
      counterIncrement(d);  counterIncrement(d);  counterIncrement(d);
      cout << counterGetValue(c) << endl;
      cout << counterGetValue(d) << endl;
      return 0;
    }
 
 
#+end_src

** Abstract data types (ADT)
 

#+begin_src c++
    struct Counter {
      unsigned int value;
      unsigned int upper;
    };
 
#+end_src

 - Can implement as before
 
 - Problems: 
 - no data encapsulation
 - no initialization guarantees
 
 - No encapsulation

#+begin_src c++
    Counter c;
    counterInitialize(c, 0, 3);
    c.value = 999; // allowed!
 
#+end_src

 - No initialization guarantees

#+begin_src c++
    // Precondition:
    //  <1> The counter module must 
    // have been properly initialized
    Counter c;
    cout << counterGetValue(c) << endl;
 
#+end_src

* Abstract Data Types via Classes
 
 
 
 - Declaring ADT as classes, data representation, member functions, public vs. private functions, constructors
 
** Classes
 
 - Classes are record types, and thus have fields, but can also declared member functions

#+begin_src c++
    // counter.h
    class Counter {
    public:
    // initialize
    void initialize(unsigned int value1, unsigned int upper1);
    // getValue
    unsigned int getValue();
    // increment
    void increment();
    private:
    // Data representation to follow ...
    };
 
#+end_src

 
 - Public member functions can be used elsewhere
 - how about public static ones?
 - Private member functions have class scope 
 - (cf. file scope as in static or namespaces)

#+begin_src c++
    Note: member functions no longer take the counter as argument; why?
#+end_src

 -  void initialize(unsigned int value1, unsigned int upper1)
 - Public vs. private fields/member functions of a class
 - how to call/invoke public member functions? 
 - how to define/implement a member function?
 
 

#+begin_src c++
    #include "counter.h"
 
    int main( ) {
    Counter c, d;
    c.initialize(0, 3);
    d.initialize(0, 10);
 
    c.increment(); 
    c.increment(); 
    c.increment();
    d.increment();
    d.increment();
    d.increment();
 
    cout << c.getValue() << endl;
    cout << d.getValue() << endl;
 
    return 0;
    }
 
#+end_src

 

#+begin_src c++
    class Counter {
    public: 
    ... ... ...
    private: // encapsulation
    unsigned int value; // current value of the counter
    unsigned int upper; // upper bound of valid counter values
    };
 
    int main() {
    Counter c;
    c.initialize(0, 3);
 
#+end_src

 

#+begin_src c++
    // counter.cpp
 
    #include "counter.h"
 
    void Counter::initialize(unsigned int value1, unsigned int upper1) {
    assert(value1 < upper1);
    value = value1;
    upper = upper1;
    }
 
    unsigned int Counter::getValue() {
    return value;
    }
 
    void Counter::increment() {
    value++;
    if (value == upper)
    value = 0;
    }
    //not using Counter:: will make the 
    //declarations global!
 
#+end_src

 

#+begin_src c++
    // counter.h
 
    class Counter {
    public: 
    ... ... ...
    private: // encapsulation
    // isInvariantTrue
      bool isInvariantTrue();
    };
 
    // counter.cpp
    #include "counter.h"
 
    void Counter::initialize(unsigned int value1, unsigned int upper1) {
    assert(value1 < upper1);
    value = value1;
    upper = upper1;
    assert(isInvariantTrue());
    }
 
#+end_src

** Classes (constructors)
 
 - Can declare a class constructor
 - special kind of member function 
 - automatically invoked when an instance of the class is created 
   + intended to perform initialization (forces to initialize when creating instances!) 

#+begin_src c++
    // counter.h
    class Counter {
    public:
    // Constructor
    // Purpose: Initialize a counter instance
     Counter(unsigned int value1, unsigned int upper1);
    ...
    };
 
#+end_src

 

#+begin_src c++
    // counter.cpp
 
    Counter::Counter(unsigned int value1, unsigned int upper1){
 
    assert(value1 < upper1);
    value = value1;
    upper = upper1;
    assert(isInvariantTrue());
    }
    // clientCode.cpp
 
    int main( ) {
 
    Counter c(0, 3);
    Counter d(0, 10);
    c.increment();
    ...
    Counter x; // invalid!
    }
 
#+end_src

** Another example (time accumulator)
 

#+begin_src c++
    // time.h
    Class Time{
    public:
    // Constructor
    Time(unsigned int hrs, unsigned int mins, unsigned int secs);
    // increment
    void increment(unsigned int hrs, unsigned int mins, unsigned int secs);
    // equals
    bool equals(const Time &t);  
    // lessThan
    bool lessThan(const Time &t);
 
#+end_src

 

#+begin_src c++
    // getComponents
    void getComponents(unsigned int &hrs, unsigned int &mins, unsigned int &secs);
    // increment
    void increment(unsigned int hrs, unsigned int mins, unsigned int secs);
    // add
    Time add(const Time &t);
    // diff
    Time diff(const Time &t);
    private:
    // Data representation to follow ...
    };
 
#+end_src

 

#+begin_src c++
    #include "time.h"
    int main( ) {
    unsigned int hrs, mins, secs;
    Time t1(0, 30, 45);
    t1.increment(0, 0, 15);
    Time t2(0, 30, 0);
    Time t3 = t1.add(t2);
    Time t4(0, 1, 0);
    Time t5 = t3.diff(t4);
    t5.getComponents(hrs, mins, secs);
 
    cout << hrs << : << mins << : << secs << endl;
 
    Return 0;
    }
 
#+end_src

 

#+begin_src c++
    // time.h
    class Time {
    public:
    ...
    private:
    // Another constructor
    Time(unsigned long int secs);
 
 
 
    private:
    unsigned long int seconds;
    };
 
 
#+end_src

 

#+begin_src c++
    // time.cpp
    #include <cassert>
    #include "time.h"
    namespace {
    const unsigned long int SECS_IN_MIN  = 60;
    const unsigned long int MINS_IN_HOUR = 60;
const unsigned long int SECS_IN_HOUR = SECS_IN_MIN * MINS_IN_HOUR;
 
    unsigned long int convertToSecs(unsigned hrs, unsigned mins, unsigned secs) {
return hrs * SECS_IN_HOUR + mins * SECS_IN_MIN + secs;
    }
    }
 
#+end_src

 

#+begin_src c++
    // time.cpp
    Time::Time(unsigned int hrs, unsigned int mins, unsigned int secs) {
    assert(mins < 60);
    assert(secs < 60);
    seconds = convertToSecs(hrs, mins, secs);
    }
    void Time::increment(unsigned int hrs, unsigned int mins, unsigned int secs) {
    assert(mins < 60);
    assert(secs < 60);
    seconds += convertToSecs(hrs, mins, secs);
    }
 
#+end_src

 

#+begin_src c++
    // time.cpp
    bool Time::equals(const Time &t) {
    return seconds == t.seconds;
    }
    bool Time::lessThan(const Time &t) {
    return seconds < t.seconds;
    }
    void Time::getComponents(unsigned int &hrs, unsigned int &mins, unsigned int &secs) {
    hrs  =  seconds / SECS_IN_HOUR;
    mins = (seconds / SECS_IN_MIN) % MINS_IN_HOUR;
    secs =  seconds % SECS_IN_MIN;
    }
 
#+end_src

 

#+begin_src c++
    // time.cpp
 
    Time Time::add(const Time &t) {
    Time result(seconds + t.seconds);
    return result;
    }
 
 
 
 
    Time Time::diff(const Time &t) {
    assert(!lessThan(t));
    Time result(seconds - t.seconds);
    return result;
    }
 
    // second constructor!
    Time::Time(unsigned long int secs) {
    seconds = secs;
    }
 
#+end_src

** Time accumulator example
 
 - Note the second (private) constructor on slide 13 and 17
 - used by add( ) and diff( )
 - in general, can have many
 - Could have implemented add( ) and diff( ) differently

#+begin_src c++
    Time Time::add(const Time &t) {
      return Time(seconds + t.seconds);
    }
    Time Time::diff(const Time &t) {
      assert(! lessThan(t));
      return Time(seconds - t.seconds);
    }
 
#+end_src

** Time accumulator example
 
 - Above alternative implementation creates a temporary, anonymous instance of Time and returns it right away (more efficient)
 - no intermediate variables are declared 
 - Another example (where 2 temporary instances are created):

#+begin_src c++
    Time t = Time(1, 0, 45).add(Time(0, 30, 15));
#+end_src

 - BTW, compilers can usually optimize your code to do this
 
** Default constructor
 
 - Has no parameters
 - Invoked by compiler if the client did not invoke another constructor 

#+begin_src c++
    // time.h
    class Time {
    public:
    // Default Constructor
    Time( );
    ...
    };
    // time.cpp
    Time::Time( ) {
    seconds = 0;
    }
 
    // client code in main
    Time x;
    Time y(13,13,13);
    Time z( ); // invalid!
 
#+end_src

** C++ classes are records with encapsulated fields
 

#+begin_src c++
    struct Time {
    unsigned long int seconds;
    };
 
 
 
 
 
 
 
    class Time {
    public:
    ...
    private:
    unsigned long int seconds;
    };
 
 
#+end_src

** C++ classes are records with encapsulated fields
 

#+begin_src c++
    struct Time {
    public:
    Time();
    Time(unsigned int hrs, unsigned int mins, unsigned int secs);
    void increment(unsigned int hrs, unsigned int mins, unsigned int secs);
    Time add(const Time &t);
    Time diff(const Time &t);
    bool equals(const Time &t);
    bool lessThan(const Time &t);
    void getComponents(unsigned int &hrs, unsigned int &mins, unsigned int &secs);
    private:
    Time(unsigned long int secs);
    unsigned long int seconds;
    };
#+end_src

 - Only difference: by default, fields are public in structures and private in classes
 
** Thus:
 

#+begin_src c++
    class A { ... };
    void func1(A z) { ... }
 
    A x, y;
    ...
    x = y;
 
    ...
    func1(x);
 
    A func2( ) {
    A x;
    ...
    return x;
    }
 
    A z = func2( );
 
 
#+end_src

** Thus:
 
 - Just like structures, no initialization is performed by default (unless a constructor is provided)
 - If no constructors are provided, the compiler supplies a dummy one that does nothing!
 

#+begin_src c++
    class A {
    // no constructor declared here
    ...
    };
    A x; // initialization will not be performed
 
#+end_src

** Passing objects as arguments
 
 - Can be costly
 - better to pass by reference
 - sometimes want to ensure that the passed object is not modified via the const keyword
 

#+begin_src c++
    int f(const Time &t) {
    if (t.lessThan(Time(0, 30, 0))) // valid: lessThan is const 
    t.increment(0, 30, 0);             // invalid: increment is not const
    }
 
 
#+end_src

** const member functions
 

#+begin_src c++
    Time add(const Time &t); // in Time class
    Time t3 = t1.add(t2);        // in main function
 
#+end_src

 
 - Use the following declaration instead

#+begin_src c++
    Time add(const Time &t) const; // in Time.h
 
    Time Time::add(const Time &t) const {  // in Time.cpp
    increment(1,15,30); // invalid!
    ...
    }
 
#+end_src

* Searching and sorting
 
 
 
 - Linear search, binary search, selection sort, insertion sort
 
** Notions related to program correctness
 
 - Soundness: is the output always as expected?
 - if the program produced output, 
 - then the output is correct
 
 - Completeness: does the program always produce an output?
 - if there exists a solution, 
 - then the program will produce an output 
 
 - Correct: sound and complete
 
 - Partially correct: sound but not complete 
 - (program may not halt on some inputs)
 
 - Loop invariant: conditions that are true before the loop and after every iteration
 
** Linear search
 

#+begin_src c++
    typedef int ItemType;
 
      //
      // Helper function: linearSearch
      //
      // Purpose: Locate the first occurrence of x in the array A.
      // Parameter(s):
      //  <1> x: An ItemType item to be sought.
      //  <2> A: An array of ItemType in which the search is to be conducted.
      //  <3> n: An unsigned integer indicating the scope of the search.
      // Precondition(s): N/A
      // Returns: If x occurs in A[0:n], then the index of the first occurrence will be returned.
      // Otherwise, -1 will be returned.
      // Side Effect: N/A
 
 
#+end_src

** Linear search
 

#+begin_src c++
    int linearSearch(const ItemType x, const ItemType A[], unsigned int n) {
    for (unsigned int i = 0; i < n; i++){
    if (x == A[i]){
    return i;
    }
    }
    return -1;
    }
 
#+end_src

 - Time complexity: as the name suggests, linear 
 
** Binary search
 
 - Works correctly on sorted data only
 - Will find some occurrence of searched item x (may not be the first one)
 
 - Check the middle item m 
 - if x == m, we have found x
 - if x < m then x will not be located to the right of m, and thus x should be sought for in the subarray to the left of m
 - if the x > m then x will not be located to the left of m, and thus x should be sought for in the subarray to the right of m
 
** Binary search
 

#+begin_src c++
     //
      // binarySearch
      //
      // Purpose: To determine if an array contains the specified element.
      // Parameter(s):
      //  <1> x: The element to search for
      //  <2> A: The array to search in
      //  <3> n: The length of array A
      // Precondition(s): N/A
      // Returns: Whether element x is in array A.
      // Side Effect: N/A
 
 
#+end_src

** Binary search
 
 -  bool binarySearch(ItemType x, 

#+begin_src c++
    const ItemType A[], unsigned int n){
/*1*/    int low = 0;
/*2*/    int high = n - 1;
 
 
 
 
 
 
 
 
/*3*/    while (low <= high) {
/*4*/         int mid = (low + high) / 2;
/*5*/         if (x == A[mid])
/*6*/              return true;
/*7*/         else if (x < A[mid])           
/*8*/              high = mid - 1;
/*9*/         else
/*10*/            low = mid + 1;
                 } //end while
/*11*/   return false;
           }
 
#+end_src

** Binary search
 
 - If the array holds 32 items, needs roughly 5 steps
 - If the array holds 2048 items, needs roughly 11 steps
 - why?
 
 - In general, in the worst case, at most ?log2(n)? + 1 steps
 
 - How about 7 items?
 
** Sorting
 
 - What is sorting?
 - rearranging items in some sort of order (either ascending or descending)
 - examples
 - useful for many applications 
 - many known sorting algorithms exist: selection sort, insertion sort, bubble sort, quick sort, merge sort, heap sort, shell sort, radix sort, etc. 
 - each have different performance characteristics (e.g., quick sort is the fastest in the average case, while heap sort and merge sort are the fastest in the worst case)
 
** The selection sort algorithm
 
 - The minimum member of the original array will be the first element of the sorted array
 - If we take away the the first element, then the minimum element of the remaining subarray will be the second element in the sorted order
 - If we take away the second element, then the minimum element of the remaining subarray will be the third element in the sorted order
 - ... so on and so forth
 - So, repeatedly select the minimum element from the remaining elements and places it next in the ordering, until all elements have been ordered
 - Example using 2 arrays?
 
** The selection sort algorithm
 
 - Sort array A[n]:
 

#+begin_src c++
    for (i = 0; i < n; i++){
#+end_src

 - 1. find the min element in the unsorted array
 - 2. remove min element from unsorted array
 - 3. place min element at index i of sorted array

#+begin_src c++
    }
 
 
#+end_src

** The selection sort algorithm
 
 - Sort array A[n]:
 

#+begin_src c++
      for (i = 0; i < n; i++){
#+end_src

 - 1. find the min element in the unsorted region of array A
 - 2. swap the min element with the element at index i

#+begin_src c++
      }
 
 
#+end_src

** The selection sort algorithm
 
 - Recall loop invariants: at the end of each iteration i
 - the subarray A[0..i-1] is a prefix of the sorted array 
 - the subarray A[i..n] contains the remaining elements in some arbitrary order
 
 - Refined version:
 

#+begin_src c++
      for (i = 0; i < n; i++){
#+end_src

 - 1. find the min element in A[i..n]
 - 2. swap the min element with A[i]

#+begin_src c++
      }
 
 
#+end_src

** The selection sort algorithm
 

#+begin_src c++
    void selectionSort(ItemType A[], unsigned int n){
    for (unsigned int i = 0; i < n; i++){
    unsigned int m = min(A, i, n);
    swap(A[i], A[m]);
    }
    }
 
 
#+end_src

** The selection sort algorithm
 

#+begin_src c++
    unsigned int min(const ItemType A[], unsigned int begin, unsigned int end){
    assert(begin <= end);
    unsigned int m = begin;
    for (unsigned int i = begin + 1; i < end; i++){
    if (A[m] > A[i])
    m = i;
       }
          return m;
    }
 
 
#+end_src

** The selection sort algorithm
 

#+begin_src c++
    void swap(ItemType &x, ItemType &y) {
    ItemType tmp = x;
    x = y;
    y = tmp;
    }
 
 
#+end_src

** The selection sort algorithm
 

#+begin_src c++
    void selectionSort(ItemType A[], int N){
        int i, j, search_min;
        ItemType temp;
 
        for (i = 0; i < N; i++) {
          // Find index of smallest element
          search_min = i;
          for (j = i + 1; j < N; j++) {
            if (A[j] < A[search_min])
              search_min = j;
          }
          // Swap items
          temp = A[search_min];
          A[search_min] = A[i];
          A[i] = temp;
        } // end for
      }
 
#+end_src

** The insertion sort algorithm
 
 - Divide the unsorted array into two regions 
 - sorted "left" region/subarray
 - unsorted "right" region/subarray
 - Incrementally take one element from the unsorted region
 - insert it into the sorted region to generate a sorted region that is one element larger
 - Rinse and repeat
 
 
 - Sorting happens when inserting element (and not when selecting it)
 
** The insertion sort algorithm
 
 - Sort A[n]:
 

#+begin_src c++
    for i ranging from 0 to n-1 do {
    Select x = A[i];
    Insert x into sorted region on the left;
    }
 
#+end_src

 - Example?
 
** The insertion sort algorithm
 
 - At the end of each iteration i:
 - the subarray A[0..i] is sorted, 
 - while the subarray A[i+1..n] is in some arbitrary order
 
 - Sort A[n]:
 

#+begin_src c++
    for i ranging from 0 to n-1 do {
    Select x = A[i];
    Insert x into subarray A[0..i];
    }
 
#+end_src

** The insertion sort algorithm
 

#+begin_src c++
    void insertionSort(ItemType A[], unsigned int n) {
    for (unsigned int i = 0; i < n; i++) {
    ItemType x = A[i];
    // Find insertion point
    unsigned int j = find(x, A, i);
    // Shift elements
    shiftRight(A, j, i);
    // Store element
    A[j] = x;
    }
      }
 
#+end_src

** The insertion sort algorithm
 

#+begin_src c++
    unsigned int find(ItemType x, const ItemType A[], unsigned int n) {
    for (unsigned int i = 0; i < n; i++) {
    if (A[i] >= x)
       return i;
    }
        return n;
    }
 
 
#+end_src

** The insertion sort algorithm
 

#+begin_src c++
    void shiftRight(ItemType A[], unsigned int begin, unsigned int end) {
    assert(0 <= begin);
    assert(begin <= end);
 
    for (unsigned int j = end; j > begin; jÑ)
    A[j] = A[j-1];
 
    }
 
 
#+end_src

** The insertion sort algorithm
 

#+begin_src c++
     void insertionSort(DataType A[], int N) {
        int i, j, insert_index;
        DataType x;
 
        for (int i = 0; i < N; i++) {
          // save the element from position i
          x = A[i];
 
          // Find the insertion point
          insert_index = 0;
#+end_src

 -       while ((insert_index < i) && (x > A[insert_index]))

#+begin_src c++
            insert_index++;
          // Shift the elements
          for (j = i; j > insert_index; j--)
            A[j] = A[j-1];
 
          // Store x at the insertion point
          A[insert_index] = x;
        }
      }
 
 
#+end_src

* Constructors and overloading
 
 
 
 - Function overloading, type coercion, operator overloading 
 
** Default constructors (revisited)
 
 - Default constructor written by the programmer
 - constructor creates an empty Multiset
 

#+begin_src c++
    class Multiset {
    public:
    Multiset();
    ...
    };
 
#+end_src

 - Default constructor provided by the compiler
 

#+begin_src c++
    Client code: Multiset m; // but not Multiset m( );
 
 
 
#+end_src

** Constructors
 
 - Want to insert all elements of an array A of size n into Multiset

#+begin_src c++
    int A[5] = { 2, 5, 4, 3, 1 };
    Multiset m;
    for (int i = 0; i < 5; i++)
    m.insert(A[i]);
 
#+end_src

 - If frequently done, might as well write a constructor

#+begin_src c++
    class Multiset {
    public:
    Multiset();
    Multiset(const ItemType A[], unsigned int n);
    ...
    };
 
#+end_src

** Constructors
 
 - Client code

#+begin_src c++
    int A[5] = { 2, 5, 4, 3, 1 };
    Multiset m(A, 5);  // Invoking the constructor with an array argument followed 
                                // by an integral argument
 
#+end_src

 - If frequently done, might as well write a constructor

#+begin_src c++
    Multiset::Multiset(const ItemType A[], unsigned int n) {
    assert(n <= MAX_LENGTH);
    data_count = n; // Copy size
    // Copy array
    for (unsigned int i = 0; i < n; i++)
    data[i] = A[i];
    // Sort to normalize representation
    sort(data, data_count);  // e.g., any sorting algorithm
    }
 
#+end_src

** Constructors
 
 - Want to create a Multiset with n copies of the same item x
 

#+begin_src c++
    Multiset(ItemType x, unsigned int n);
 
    Client code: Multiset m(999, 5);  // A multiset of 5 copies of 999
 
#+end_src

 - implementation
 

#+begin_src c++
    Multiset::Multiset(ItemType x, unsigned int n) {
    data_count = n;
    for (unsigned int i = 0; i < n; i++)
    data[i] = x;
    }
 
#+end_src

** Other uses of constructors
 
 - Anonymous objects can be useful and efficient
 

#+begin_src c++
    Counter c1, c2;         // ordinary variables initialized using default constructor
    Counter c3(0, 3);       // ordinary variable initialized using initializing constructor
    c1 = Counter( );         // unnamed instance constructed with default constructor
    c2 = Counter(0, 10);  // unnamed instance constructed with initializing constructor
 
    Counter ctr1[MAX];
    ctr1[5] = Counter(0,3);
 
#+end_src

 
 - Creating anonymous objects for function call

#+begin_src c++
    House h1(500000);
    ...
    House p = h1.add(House(1000000));
 
#+end_src

 - Creating anonymous for the purpose of returning it 

#+begin_src c++
    House House::add(const House &other) const {
    if (price == 0 && other.price == 0) {
    // return instance made with default constructor
    return House( );
    }
    else
    return House(price + other.price);
    }
 
#+end_src

** Overloading
 

#+begin_src c++
    int myMax(int a, int b) {
    if (a > b)
    return a;
    else 
    return b;
    }
 
    float myMax(float a, float b) {
    if (a > b)
    return a;
    else 
    return b;
    }
    int main( ) {
 
    // invoke myMax(float, float)
    cout << myMax(1.2f, 4.7f); 
    // invoke myMax(int, int)
    cout << myMax(3, 4);   
 
    return 0;
    }
 
 
#+end_src

** Overloading
 

#+begin_src c++
    int myMax(int a, int b) {
    if (a > b)
    return a;
    else 
    return b;
    }
 
    int myMax(int a, int b, int c) {
    return myMax(a, myMax(b, c));
    }
 
#+end_src

 - How about different return types only? (nope!)

#+begin_src c++
    int main( ) {
 
    // invoke myMax(int, int)
    cout << myMax(3, 4);   
 
    // invoke myMax(int, int, int)
    cout << myMax(3, 4, 5);  
 
    return 0;
    }
 
 
#+end_src

** Overloading
 

#+begin_src c++
    // header 
    void print( ) const;
    void print(ostream &output_stream) const;
    // client code
    L.print();
    L.print(cout);
    // definition
    void Multiset::print( ) const {
    print(cout);
    }
    void Multiset::print(ostream& output_stream) const {
    for (unsigned int i = 0; i < data_count; i++) {
    if (i != 0)
    output_stream << ", ";  // comma separation for all except the first member
        output_stream << data[i];
    }
    }
 
#+end_src

** Type coercions
 
 - AKA implicit (static or dynamic) type conversion
 - Occurs when evaluating expressions, passing values to functions, and returning values from functions
 - No warning produced by compiler unless has possibility of information loss
 
 - Coercion order:
 - double <- float <- long int <- int <- short int <- char
 - No warnings are provided for type upgrade given in the above order
 - ``safe coercion 
 
** Type coercions (examples)
 

#+begin_src c++
    void myMax(float f1, float f2); // 1Avoid myMax(int i1, int i2); // 1BmyMax(7, 9);
 
    void zipIt(float f1); // 2Avoid zipIt(string s1); // 2BString s = "Trouble";zipIt(s);
 
    void zoom(float f1); // 3Avoid zoom(string s1); // 3Bint x = 14;zoom(x);
    void whoosh(char c1); // 4Avoid whoosh(string s1); // 4Bdouble pi = 3.14159;whoosh(pi);
 
    void crunch(string s1, string s2); // 5Avoid crunch(string s1); // 5Bdouble e = 2.71828;crunch(e);
 
#+end_src

 - 1: None (1B)               2: None (2B) 
 - 3: Safe (3A) 
 - 4: Unsafe and possibly warning (4A)
 - 5: Error! 
 
 

#+begin_src c++
    void mixed(int i1, double d1); // 6Avoid mixed(double d1, int i1); // 6Bint k3 = 3, k4 = 4;mixed(k3, k4);
 
    void mixed(int i1, double d1); // 7Avoid mixed(double d1, int i1); // 7Bdouble r5 = 55.5, r6 = 66.6;mixed(r5, r6);
 
#+end_src

 - 6: both safe but ambiguous 
 - 7: both unsafe and ambiguous
 
** Operator overloading
 
 - Gives more than one meaning to the same operator
 - Operands (arguments to operators) are new data types
 - thus, overloading the operator 
 - Uses keyword operator
 

#+begin_src c++
    	// equality operator
    	bool operator== (const House &h) const;
 
    	// assignment operator
    	House &operator= (const House &h);
 
#+end_src

** Operator overloading (example)
 

#+begin_src c++
    class House {
    	string address;
    	string owner;
    	unsigned int cost;
    	bool fireplace;
        public:
    	// default constructor
    	House();
 
    	// initializing constructor
#+end_src

 - 	House(const string &initAddress,
 - 	      const string &initOwner,
 - 	      unsigned int initCost,

#+begin_src c++
    	      bool initFireplace);
 
 
    	// copy constructor
    	House(const House &original);
 
    	// equality operator
    	bool operator== (const House &h) const;
 
    	// assignment operator
    	House &operator= (const House &h);
 
    	House &operator+= (const House &h);
 
    	House operator+ (const House &h);
 
    	void print() const;
    };
 
#+end_src

** Implementing ==
 
 

#+begin_src c++
    bool House::isEquals(const House &h) const {
    if (address != h.address) return false;
    if (owner != h.owner) return false;
    if (cost != h.cost) return false;
    if (fireplace != h.fireplace) return false;
    return true;
    }
 
#+end_src

 - We could have implemented it as follows
 

#+begin_src c++
    bool House::operator==(const House &h) const {
    ...
    }
 
#+end_src

** The == operator
 
 - Can now use it as an operator 
 

#+begin_src c++
    House h1, h2;
    ...  // initialize fields of h1 and h2
 
    if (h1 == h2) {
    // do something useful
    }
 
 
#+end_src

** Implementing assignment operator (=) 
 

#+begin_src c++
    void House::operator=(const House &h) {
    address = h.address;
    owner = h.owner;
    cost = h.cost;
    fireplace = h.fireplace;
    }
 
#+end_src

 - All good, works for a = b 
 - But does not allow assignment statements to be chained 
 - for this, need to mutable House type object (i.e. reference)
 
 
** Implementing assignment operator (=) 
 

#+begin_src c++
    House &House::operator=(const House &h) { // & is used for efficiency only!
    if (this != &h) {
    address = h.address;
    owner = h.owner;
    cost = h.cost;
    fireplace = h.fireplace;
    }
return *this;
    }
 
#+end_src

 - this is a pointer to the reference object
*this are the ``contents of the reference object
 
 
** Assignment operator (=) 
 

#+begin_src c++
    House h1, h2, h3;
    h1.setCost(500); h2.setcost(700); h3.setCost(900);
 
    h1 = h2 = h3;  // same as h1.operator=(h2.operator=(h3));
 
    h1.printCost(); // prints 900
 
 
 
#+end_src

** Implementing addition operator (+) 
 

#+begin_src c++
    House House::operator+ (const House &h) {
 
    House newHouse;
newHouse = *this;
 
    newHouse.address += " + " + h.address;
    newHouse.owner += " + " + h.owner;
    newHouse.cost += h.cost;
    newHouse.fireplace = newHouse.fireplace || h.fireplace;
 
    return newHouse;
    }
 
 
#+end_src

** Implementing increment operator (+=) 
 

#+begin_src c++
    House &House::operator+= (const House &h) {
 
    address += " + " + h.address;
    owner += " + " + h.owner;
    cost += h.cost;
    fireplace = fireplace || h.fireplace;
 
return *this;
 
    }
 
 
#+end_src

** Reimplementing addition operator (+) 
 

#+begin_src c++
    House House::operator+ (const House &h) {
 
    House newHouse;
newHouse  = *this;
 
    newHouse += h;
 
    return newHouse;
 
    }
 
#+end_src

** Overloading non-member operations
 
 - What if you did not write the House class? 
 - no problem, implement it as a non-member function with an additional House argument (standing for the reference object)
 

#+begin_src c++
    House operator+ (const House &h1, const House &h2) {
    House newHouse;
    newHouse  = h1;
    newHouse += h2;
    return newHouse;
    }
 
#+end_src

 - Similarly for the case when the first operand is a primitive type
 
** Overloading non-member operations
 
 - Want to add a stream insertion operator (operator<<) to the House class

#+begin_src c++
    myStream << h1;
 
    void operator<< (ostream &out, const House &h) {
    out << "Location: "  << address   << endl;
    out << "Owner: "     << owner     << endl;
    out << "Cost: "      << cost      << endl;
    out << "Fireplace: " << fireplace << endl;
    out << endl;
    }
 
#+end_src

 - One issue: fields (e.g. address) are private! 
 
** Overloading non-member operations
 

#+begin_src c++
    class House {
    void print(ostream &out) const;
    ...
    };
 
    void House::print(ostream &out) const{
    	out << "HOUSE"<< endl;
    	out << "Fireplace: "<< fireplace<< endl;
    	out << endl;
    }
 
    void House::print() const{
    	print(cout);
    }
 
    void operator<< (ostream &out, const House &h) {
    	h.print(out);
    }
 
    With this, cout << h2; works as intended
 
#+end_src

** Overloading non-member operations
 

#+begin_src c++
    But cout << h2 << endl; will give compile time error!
 
#+end_src

 - Use the following implementation instead:
 

#+begin_src c++
    ostream &operator<< (ostream &out, const House &h) {
    h.print(out);
    return out;
    }
 
 
#+end_src

* Object-oriented design
 
 
 
 - Composition, inheritance, polymorphism, dynamic binding, hidden functions & operators  
 
** Terminology
 
 - Top-down design: process of repeatedly decomposing a complicated problem into smaller, more manageable subproblems that can be solved by functions that can be implemented independently of the rest of the project
 - Object-oriented design (OOD): software design technique where the problem domain is decomposed into a set of objects that together solve a software problem
 
 - Classes (allows us to define ADT)
 - Objects (=class instances)
 - Fields (=class member fields/variables)
 - Methods (=class member functions)
 - Message Passing (=invocation of member functions through an object)
 
** Composition 
 
 - Idea:
 - say we want to define a class P1
   + conceptually divide P1 into constituent parts 
 - in the definition of the P1 class, declare instances of its constituents (which are other classes, say C1, C2, and C3)
 - C++ compiler will call all of the constituent classes C1, C2, and C3s default constructors before it calls P1s constructor 
 - C++ syntax allows you to call other constructors of C1, C2, and C3 if needed, and pass the appropriate arguments in their parameters
 - use the methods of C1, C2, and C3 using the declared objects while implementing the methods of P1
 
** Composition (example)
 

#+begin_src c++
    class Bicycle {
    private:
    	Wheel front_wheel;
    	Wheel back_wheel;
    	Seat seat;
    public:
    	Bicycle ();
#+end_src

 - 	Bicycle (string wheel_manufacturer1,      
 -                 string wheel_product1,
 -                 int diameter_in_inches1, 
 -                 int weight_in_grams1, 
 -           	    int spokeCount1,
 - 		          string wheel_manufacturer2, 
 -                 string wheel_product2,
 - 		 int diameter_in_inches2, 
 -        int weight_in_grams2, 
 - 		 int spokeCount2,
 - 		 string seat_manufacturer1, 
 -        string seat_product1,

#+begin_src c++
    		 string seat_colour1);
    	Bicycle (const Bicycle& original);
    	~Bicycle ();
    	Bicycle &operator= (const Bicycle &original);
    	void read  (istream &in);
    	void print (ostream &out);
    };
 
#+end_src

** Composition (example)
 
 - Bicycle::Bicycle()
 - 	: front_wheel(), back_wheel(),seat()

#+begin_src c++
    {
    // body of default constructor
    }
 
 
#+end_src

 - What happens when you declare a Bicycle object?

#+begin_src c++
    Bicycle b;
 
#+end_src

** Composition (example)
 
 - Bicycle::Bicycle (string wheel_manufacturer1, string wheel_product1, int diameter_in_inches1, 
 - int weight_in_grams1, int spokeCount1, string wheel_manufacturer2, 
 - string wheel_product2, int diameter_in_inches2, int weight_in_grams2, int spokeCount2,
 - string seat_manufacturer1, string seat_product1, string seat_colour1)
 - 	: front_wheel (wheel_manufacturer1, wheel_product1,
 - 		 diameter_in_inches1, weight_in_grams1, spokeCount1),
 - 	  back_wheel (wheel_manufacturer2, wheel_product2,
 - 		 diameter_in_inches2, weight_in_grams2, spokeCount2),
 - 	  seat (seat_manufacturer1, seat_product1, seat_colour1)

#+begin_src c++
    {
    // body of initializing constructor
    }
 
#+end_src

** Composition (example)
 

#+begin_src c++
    class Seat {
    private:
    	string manufacturer;
    	string product;
    	string colour;
    public:
    	Seat ();
    	Seat (string manufacturer1, string product1, string colour1);
    	Seat (const Seat &original);
    	~Seat ();
    	Seat &operator= (const Seat &original);
    	void read  (istream &in);
    	void print (ostream &out);
    };
#+end_src

 - Seat::Seat (string manufacturer1, 
 -                    string product1, string colour1)

#+begin_src c++
    	: manufacturer(manufacturer1), // copy cons
    	  product(product1), //copy constructor 
    	  colour(colour1) //copy constructor
    {
    	// body of initializing constructor
    }
 
#+end_src

 - Seat::Seat (const Seat &original)
 - 	: manufacturer(original.manufacturer),
 - 	  product(original.product), 

#+begin_src c++
    	  colour(original.colour) {
    // body of initializing constructor
    }
 
 
#+end_src

** Composition (example)
 
 - Bicycle::Bicycle (const Bicycle &original)
 - 	: front_wheel (original.front_wheel),
 - 	  back_wheel (original.back_wheel),
 - 	  seat (original.seat)

#+begin_src c++
    {
    // body of copy constructor
    }
 
#+end_src

** Composition (another example)
 

#+begin_src c++
    typedef int ItemType;
 
    class GuardedArray {
    public:
    static const unsigned int LENGTH = 500;
    GuardedArray();
    GuardedArray(ItemType x);
    ItemType retrieve(unsigned int i) const;
    void store(unsigned int i, ItemType x);
    private:
    ItemType data_array[LENGTH];
    };
 
#+end_src

** Composition (another example)
 

#+begin_src c++
    GuardedArray::GuardedArray() {
    for (unsigned int i = 0; i < LENGTH; i++)
    data_array[i] = 0;
    }
 
    GuardedArray::GuardedArray(ItemType x) {
    for (unsigned int i = 0; i < LENGTH; i++)
    data_array[i] = x;
    }
 
    ItemType GuardedArray::retrieve(unsigned int i) const {
    assert(i < LENGTH);
    return data_array[i];
    }
 
    void GuardedArray::store(unsigned int i, ItemType x) {
    assert(i < LENGTH);
    data_array[i] = x;
    }
 
 
#+end_src

** Composition (another example)
 

#+begin_src c++
    class ManagedArray {
 
    public:
    static const unsigned int MAX_LENGTH = GuardedArray::LENGTH;
 
    ManagedArray();
    ManagedArray(unsigned int n);
    ManagedArray(unsigned int n, ItemType x);
 
    unsigned int length() const;
    ItemType retrieve(unsigned int i) const;
    void store(unsigned int i, ItemType x);
    void insert(unsigned int i, ItemType x);
    void remove(unsigned int i);
 
    private:
    unsigned int count;
    GuardedArray guaurded_array;
 
    };
 
 
#+end_src

** Composition (another example)
 

#+begin_src c++
    ManagedArray::ManagedArray(unsigned int n, ItemType x) : guaurded_array(x) {
    assert(n <= MAX_LENGTH);
    count = n;
    }
 
    ItemType ManagedArray::retrieve(unsigned int i) const {
    assert(i < length());
    return guaurded_array.retrieve(i);
    }
 
 
#+end_src

** Composition (another example)
 

#+begin_src c++
    void ManagedArray::insert(unsigned int i, ItemType x) {
    assert(i <= length());
    assert(count < MAX_LENGTH);
 
    for (unsigned int j = count; j > i; jÑ)
    guaurded_array.store(j, guaurded_array.retrieve(j-1));
    guaurded_array.store(i, x);
    count++;
    }
 
 
#+end_src

** Composition (yet another example)
 
 - Can in turn define Multiset using ManagedArray (see notes for full details)
 
 - Another approach (inheritance):
 
 - start with base class (parent/super-class) that gives a vague idea of the objects that we are after
 
 - define other more specialized derived classes (child/sub-classes) that ``inherits everything in the parent class
 
 - can create a hierarchy of classes linked by the ancestor-descendant relation  
 
** Inheritance
 
 - Child class inherits everything in the parent class 
 - when an object of the child class is instantiated, 
 - all fields of the parent class will be allocated
 
 - But can only directly access some fields and methods
 - those that are public (and protected)
 
 - Child class can re-implement some functions of the parent!
 - this is called function overriding
 
 - Add to this mix the hierarchy of classes
 - e.g. C extends P, GC extends C 
 - then all publicly inherited public fields of C will be members of GC
 
** Inheritance (public vs. private)
 

#+begin_src c++
    class P {
    public:
    void f1();
    int f2() const;
    int f3() const;
    private:
#+end_src

 - int v1

#+begin_src c++
    int v2;
    };
 
 
 
 
    class C : public P {
    public:
    void f4();
    double f5() const;
    private:
    double v3;
    };
 
#+end_src

 - what happens when C x is declared?
 - can we access f1 from inside C or its clients? 
 - can we access v1 from inside C or its clients?
 - how can we access v1 from inside C or its clients?
 - what if we wrote : private p?
 
** Inheritance (hierarchy, overriding)
 
 - Can specify a hierarchy:

#+begin_src c++
    class C : public P { ... };
    class GC : public C { ... };
 
#+end_src

 - Can override an inherited function:

#+begin_src c++
    class P {
    public:
    void f1();
    };
 
    void P::f1(){
    // definition 1
    }
    class C : public P {
    public: 
    void f1();
    void f2();
    };
    void C::f1(){
    // definition 2
    }
    void C::f2(){
    f1(); // which f1?
    }
 
#+end_src

** Inheritance (constructors)
 
 - Constructor of the base class is implicitly invoked
 - Can specify constructors as well

#+begin_src c++
    class C : ... { ... };
    class D : public C {
    public:
    D(...);
    ...
    private:
    D1 f1;
    D2 f2;
    ...
    };
    D::D(...) : C(...), f1(...), f2(...), ... 
    {
    ...
    }
 
#+end_src

 - To invoke a constructor of D:
 - a constructor C is invoked (which may initiate the invocation of other constructors)
 - a constructor of each member field fi is invoked (which may initiate the invocation of other constructors)
 - the body of the constructor of D is invoked
 
** Inheritance (protected)
 
 - Supports more flexibility
 

#+begin_src c++
    class P {
    public:
    void f1();
    protected:
    void f2();
    private:
    int x;
    };
 
 
 
    class C : public P {
    public:
    void f3();
    private:
    int y;
    };
 
    class GC : public C {
    public:
    void f4();
    private:
    int z;
    };
 
 
 
#+end_src

** Inheritance type
 
 - All permutations possible
 

#+begin_src c++
    class P {
    public:
    void f1();
    protected:
    void f2();
    private:
    int x;
    };
 
 
 
    class C1 : public P {
    ...
    };
 
    class C2 : protected P {
    ...
    };
 
    class C3 : private P {
    ...
    };
 
    // stronger qualifier ``wins !
 
 
#+end_src

 
 
 

#+begin_src c++
    class P {
    public:
    void f1();
    private:
    int x;
    };
 
    class C : protected P {
    public:
    void f3();
    };
 
 
    void C::f3(){
    f1();        // all good
    x = 7;     // error, not accessible!
    }
 
    int main(){
    P p1;
    C c1;
    p1.f1();     // works
    c1.f1();     // error, not accessible! 
    ...
    }
 
#+end_src

** Example: the Building (base) class
 

#+begin_src c++
    class Building {
 
    protected:
    // default constructor
    Building();
 
    // assignment constructor
#+end_src

 - Building(const string& address1,
 -            const string& owner1,
 -            unsigned int cost1,

#+begin_src c++
               unsigned int area1);
 
 
    protected:
    // member variables
    string address;
    string owner;
    unsigned int cost;
    unsigned int area;
 
    };
 
    // Building object!
 
#+end_src

** Example: the House (child) class
 

#+begin_src c++
    class House : public Building {
 
    public:
    // constructors
    House();
#+end_src

 - House(const string& address1,
 -         const string& owner1,
 -         unsigned int cost1,
 -         unsigned int area1,
 -         unsigned int roomCount1,
 -         bool fireplace1,

#+begin_src c++
            unsigned int applianceCount1);
 
    // print data
    void print() const;
 
    private:
    // additional member variables
    unsigned int roomCount;
    bool fireplace;
    unsigned int applianceCount;
 
    };
 
 
#+end_src

** Example: implementation of House
 
 - House::House(const string& address1,
 -              const string& owner1,
 -              unsigned int cost1,
 -              unsigned int area1,
 -              unsigned int roomCount1,
 -              bool fireplace1,
 -              unsigned int applianceCount1)
 -       : Building(address1, owner1,

#+begin_src c++
     cost1, area1) {
      roomCount = roomCount1;
      fireplace = fireplace1;
      applianceCount = applianceCount1;
    }
    void House:: print() const {
    cout << "HOUSE"<< endl;
    cout << "Location: "<< address; 
    cout << endl;
    ...
    cout << "Bedrooms: "<< roomCount; 
    cout << endl;
    ...
    }
 
 
#+end_src

** Example: the Barn (base) class
 

#+begin_src c++
    class Barn : public Building {
    public:
    // constructors
    Barn();
 
#+end_src

 - Barn(const string& address1,
 -        const string& owner1,
 -        unsigned int cost1,
 -        unsigned int area1,

#+begin_src c++
           float hayCapacity1);
 
    // print
    void print() const;
    private:
    // variables
    float hayCapacity;
 
    };
 
 
#+end_src

** Example: client code
 

#+begin_src c++
    Barn b1("123 Farmyard Lane", "Jed", 135000, 1000, 24.3);
    b1.print();
 
    House h1("321 Walnut Ave", "Clem", 182000, 2400, 3, true, 6);
    h1.print();
 
 
#+end_src

** Issues with inheritance
 
 - Implementation inheritance = examples that we have seen earlier
 - allows code reuse
 
 - Reuse can be done better using composition 
 - easier to understand code
 - encapsulation boundary are better protected 
 - less interdependencies
 
 - For code reuse, we will almost always use composition rather than implementation inheritance
 
 - Another more powerful use of inheritance = interface inheritance
 
** Interface inheritance
 
 - Rather than reusing implementation, reuse interface!
 - program to an interface, not an implementation
 

#+begin_src c++
    Say we want to develop 3 similar functions; how to rather implement one? 
#+end_src

 - via a common interface 
 
 - Key idea:
 - introduce abstract interface (the base class)
 - write the function in terms of this interface
 - develop 3 derived classes that extend this base class and implements (virtual) functions of the base class
 - c++ compiler will do the rest via dynamic binding
 
** Example: data sources
 

#+begin_src c++
    int sumArray(const int A[], unsigned int n) {
    int sum = 0;
    unsigned int i = 0;
    while (i < n) {
    sum += A[i];
    i++;
    }
    return sum;
    }
 
 
#+end_src

 

#+begin_src c++
    int sumManagedArray(const ManagedArray &A) {
    int sum = 0;
    unsigned i = 0;
    while (i < A.length()) {
    sum += A.retrieve(i);
    i++;
    }
    return sum;
    }
 
 
#+end_src

 

#+begin_src c++
    int sumStandardInputStream() {
    int sum = 0;
    int next;
    cin >> next;
    while (cin) {
    sum += next;
    cin >> next;
    }
    return sum;
    }
 
 
#+end_src

 

#+begin_src c++
    int sumDataSource(a data source) {
    int sum = 0;
    while (data source has not been exhausted) {
    sum += next entry in the data source;
    exclude the retrieved entry from future consideration;
    }
    return sum;
    }
 
 
#+end_src

 

#+begin_src c++
    class DataSource {
 
    public:
 
    // exhausted
    virtual bool exhausted() const = 0; // pure virtual function
 
    // next
    virtual int next() = 0; // pure virtual function
 
    };
 
#+end_src

 
 

#+begin_src c++
    int sumDataSource(DataSource &ds) {
    int sum = 0;
    while (! ds.exhausted()) {
    sum += ds.next();
    }
    return sum;
    }
 
#+end_src

 - Called a polymorphic function
 
 

#+begin_src c++
    const unsigned ARRAY_DATA_SOURCE_CAPACITY = 1000;
 
    class ArrayDataSource : public DataSource {
    public:
    ArrayDataSource(const int A[], unsigned int n);
    virtual bool exhausted() const;
    virtual int next();
    private:
    int data[ARRAY_DATA_SOURCE_CAPACITY];
    unsigned length;
    unsigned i;
    };
 
 
#+end_src

 

#+begin_src c++
    ArrayDataSource::ArrayDataSource(const int A[], unsigned int n) {
    assert(n < ARRAY_DATA_SOURCE_CAPACITY);
    for (unsigned int k = 0; k < n; k++)
    data[k] = A[k];
    length = n;
    i = 0;
    }
    bool ArrayDataSource::exhausted() const {
    return i == length;
    }
    int ArrayDataSource::next() {
    assert(! exhausted());
    i++;
    return data[i - 1];
    }
 
 
#+end_src

 

#+begin_src c++
    // set up and initialize managed array data source
    int A[ ] = { 1, 3, 9, -2 };
    ArrayDataSource ads(A, 4);
 
    // call sumDataSouce to add up entries
    int sum = sumDataSource(ads);
 
#+end_src

 - Which version of exhausted() and next() to use in sumDataSource(ads)?
 - determined at runtime 
 - depends on the exact type of object ads is bound to
 
 

#+begin_src c++
    class ManagedArrayDataSource : public DataSource {
    public:
    ManagedArrayDataSource(const ManagedArray &A);
    virtual bool exhausted() const;
    virtual int next();
    private:
    ManagedArray array;
    unsigned int i;
    };
 
 
#+end_src

 
 - ManagedArrayDataSource::ManagedArrayDataSource(const ManagedArray& A)

#+begin_src c++
      : array(A.length()) {
    for (unsigned int k = 0; k < A.length(); k++)
    array.store(k, A.retrieve(k));
    i = 0;
    }
    bool ManagedArrayDataSource::exhausted() const {
    return i == array.length();
    }
    int ManagedArrayDataSource::next() {
    assert(! exhausted());
    i++; 
    return array.retrieve(i - 1);
    }
 
#+end_src

 

#+begin_src c++
    // set up and initialize managed array data source
    int A[] = { 1, 3, 9, -2 };
    ManagedArray ma;
    for (unsigned int i = 0; i < 4; i++)
    ma.store(i, A[i]);
    ManagedArrayDataSource mads(ma);
 
    // call sumDataSouce to add up entries
    int sum = sumDataSource(mads);
 
 
#+end_src

** Static vs. dynamic binding
 

#+begin_src c++
    class C {
    public:
void f() { /* implementation 1 */ }
    ...
    };
 
    class D : public C {
    public:
void f() { /* implementation 2 */ }
    ...
    };
 
 
 
 
    void g(C &c) {
    c.f( );
    }
 
    int main() {
    D d;
    d.f();  // static binding: impl.2 invoked 
    g(d);  // static binding: impl.1 invoked 
    return 0;
    }
 
 
#+end_src

 

#+begin_src c++
    class C {
    public:
virtual void f() { /* implementation 1 */ }
    ...
    };
 
    class D : public C {
    public:
    // implictly virtual
void f() { /* implementation 2 */ }
    ...
    };
 
 
 
    void g(C &c) {
    c.f( );
    }
 
    int main() {
    D d;
    d.f();  // static binding: impl.2 invoked 
    g(d);  // dynamic binding: impl.2 
             // invoked 
    return 0;
    }
 
 
#+end_src

 

#+begin_src c++
    class E : public C {
    public:
    // This does not override f() in class C 
    // so it is not implicitly virtual
void f(int i) { /* implementation 3 */ }
    ...
    };
 
 
 
 
 
 
 
 
    int main() {
    E e;
    e.f();  // static binding: impl.1 invoked
    e.f(4); // static binding: impl.3 invoked
    return 0;
    }
 
 
#+end_src

** Hidden functions and operators
 
 - A function or operator in the base class with the same name and parameters as a function in the derived class
 - can still access a hidden function using the base-class type qualifier

#+begin_src c++
    void Derived1::func() {
    Base1::func(); // func() is defined in both the base and the child class Derived1
    // ...
    }
 
#+end_src

 - And similarly for operators

#+begin_src c++
    Derived1 &Derived1::operator=(const Derived1 &original) {
    if (this != &original) {
    Base1::operator=(original); // = is defined in both the base and the child class
    field1 = original.field1;
    }
	return *this;
    }
 
 
 
#+end_src

* Templates
 
 
 
 - Parametric polymorphism: template functions, template classes
 
** Motivation
 
 - Want to define both uniformly
 

#+begin_src c++
    int MaxInt(int a, int b) {
    if (b < a)
    return a;
    else
    return b;
    }
 
 
 
 
 
 
    double MaxDouble(double a, double b) {  
    if (b < a)
    return a;
    else
    return b;
    }
 
 
 
#+end_src

** Motivation
 
 - Can define a generic function with generic parameters
 

#+begin_src c++
    SomeType MaxSomeType(SomeType a, SomeType b) {
    if (b < a)
    return a;
    else
    return b;
    }
 
 
#+end_src

** Motivation
 
 - Keywords: template, typename
 

#+begin_src c++
    template <typename T> // can also use the keyword class rather than typename
    T Max(T a, T b) {
    if (b < a)
    return a;
    else
    return b;
    }
 
    Max<int>(3, 4); // or in most cases, simply: Max(3, 4);
 
 
#+end_src

** Program organization
 
 - Where should we place function templates?
 - inclusion compilation model vs. separate compilation model
 
 - We will use inclusion compilation model (as it is supported by all compilers)
 
 - Idea: 
 - place template in a header file 
 - the compiler will only generate code on instantiation 
 - avoids ``code bloat suffered by early implementations
 
** Restrictions on template abstraction
 

#+begin_src c++
    Max(string("abc"), string("def")); // works as string class overloads <
 
    Max("abc", "def"); // WRONG, as < is not defined for C strings
 
#+end_src

 

#+begin_src c++
    struct Book {
    string author;
    string title;
    };
 
 
#+end_src

** Restrictions on template abstraction
 

#+begin_src c++
    Book b1, b2;
    b1.author = "Me";
    b1.title = "BestSeller";
    b2.author="You";
 
    Max(b1,b2); // WRONG!
 
 
 
 
 
#+end_src

 - Unless we also have the following:
 

#+begin_src c++
    bool operator<(const Book &b1, const Book &b2) { 
#+end_src

 - return (b1.author < b2.author) ||

#+begin_src c++
       ((b1.author==b2.author) && (b1.title <b2.title));
    }
 
#+end_src

 - Only then:
 

#+begin_src c++
    Max(b1,b2); // Works!
 
 
#+end_src

** Specifying template abstraction
 

#+begin_src c++
    // Max.h
    //
    #pragma once
    //
    // Max<T>(a, b)
    // Purpose: Find the maximum of two given arguments.
    // Template Parameter(s):
    //  <1> T: A type for which the following operations are defined:
    //    -> copy constructor [usually automatically created by C++ compilers]
    //    -> binary less than comparison (<)
    // Parameter(s):
    //  <1> a: An instances of type T
    //  <2> b: An instances of type T
    // Precondition(s): N/A
    // Returns: A T-type value equivalent to the maximum of a and b.
    // Side Effect: N/A
 
#+end_src

** Specifying template abstraction
 
 - Earlier, could have dropped the copy constructor requirement by passing references instead:
 
 - template <typename T>

#+begin_src c++
    T &Max(T &a, T &b) {
    if (b < a)
    return a;
    else
    return b;
    }
 
#+end_src

 
** Another example
 

#+begin_src c++
    typedef int ItemType;
 
    void Swap(ItemType &a, ItemType &b){
    ItemType tmp = a;
    a = b;
    b = tmp;
    }
    unsigned int FindMin(const ItemType A[], unsigned int begin, unsigned int end){
    ...
    }
    void Sort(ItemType A[], unsigned int n){
      for (unsigned int i = 0; i < n; i++){
        unsigned int m = FindMin(A, i, n - 1);
        Swap(A[i], A[m]);
      }
    }
 
#+end_src

** Another example
 
 - template <typename ItemType>

#+begin_src c++
    void Swap(ItemType &a, ItemType &b){
      ItemType tmp = a;        // copy constructor
      a = b;                           // assignment operator
      b = tmp;		  
    }
#+end_src

 - template <typename ItemType>

#+begin_src c++
    unsigned int FindMin(const ItemType A[], unsigned int begin, unsigned int end){
      assert(begin <= end);
      unsigned int m = begin;
      for (unsigned int i = begin + 1; i <= end; i++){
      if (A[i] < A[m])    // less than comparison operator
        m = i;
      }
      return m;
    }
 
#+end_src

** Another example
 
 - template <typename ItemType>

#+begin_src c++
    void Sort(ItemType A[], unsigned int n){
    for (unsigned int i = 0; i < n; i++){
    unsigned int m = FindMin(A, i, n - 1);
    Swap(A[i], A[m]);
    }
    }
#+end_src

 - Thus the interface should include the following requirements:

#+begin_src c++
    // Template Parameter(s):
    //  <1> ItemType: A type for which the following operations are defined:
    //    -> copy constructor
    //    -> assignment operator
    //    -> binary less than comparison (<)
 
#+end_src

** Misc notes
 
 - Can have multiple different type names in template arguments (separated by a comma), e.g.:  
 
 - template <typename T, typename K, typename O>

#+begin_src c++
    T func1(K a, O b) {
    T x, y;
    ...
    if (func2(a,b)==x)
    return x;
    else
    return y;
    }
 
#+end_src

** Misc notes
 
 - Could have generalized our selection sort template to sort either in ascending or in descending order by replacing < with a function
 
 - template <typename T, bool compare(const T &x, const T &y)>

#+begin_src c++
    unsigned int Find(const T A[], unsigned int begin, unsigned int end) {
    assert(begin <= end);
    unsigned int m = begin;
    for (unsigned int i = begin + 1; i <= end; i++){
    if (compare(A[i], A[m]))
    m = i;
    }
    return m;
    }
 
#+end_src

** Misc notes
 
 - New template for sort
 
 - template <typename T, bool compare(const T &x, const T &y)>

#+begin_src c++
    void Sort(T A[], unsigned int n){
    for (unsigned int i = 0; i < n; i++){
    unsigned int m = Find<T, compare>(A, i, n - 1);
    Swap(A[i], A[m]);
    }
    }
 
 
#+end_src

** Misc notes
 

#+begin_src c++
    bool less_than(const int &x, const int &y){
    return x < y;
    }
    ...
    Sort<int, less_than>(...);
 
    bool greater_than(const int &x, const int &y){
      return x > y;
    }
    ...
    Sort<int, greater_than>(...);
 
#+end_src

** Template classes
 
 - template<typename T>

#+begin_src c++
    class Comparator{
    T x;
    T y;
    public:
    Comparator(T ax, T ay);
    bool isEquals();
    bool isGreaterThan();
    bool isLessThan();
    };
#+end_src

 - template<typename T>

#+begin_src c++
    Comparator<T>::Comparator(T ax, T ay){
    x = ax;
    y = ay;
    }
#+end_src

 - template<typename T>

#+begin_src c++
    bool Comparator<T>::isEquals(){
      return x == y;
    }
 
#+end_src

 - template<typename T>

#+begin_src c++
    bool Comparator<T>::isGreaterThan(){
      return x > y;
    }
 
#+end_src

 - template<typename T>

#+begin_src c++
    bool Comparator<T>::isLessThan(){
      return x < y;
    }
 
#+end_src

** Template classes
 

#+begin_src c++
    #include <iostream>
 
    int main() {
    Comparator<int> c1(7,3);
    std::cout << c1.isLessThan() <<"
";
 
    Comparator<double> c2(11.9,5.0);
    std::cout << c2.isLessThan() <<"
";
    }
 
#+end_src

* Pointers
 
 
 
 
** Motivation
 
 - Reference = alias for another variable
 
 - Pointer = address of another variable stored elsewhere in memory 
 
 - Like references, but much more powerful
 - can be initialized to anything!
 - can change over time (unlike references)

#+begin_src c++
    can do pointer arithmetic (pointer arguments are evaluated when passed to functions during function invocation; see first lecture slides!)
 
#+end_src

Examples of initialization, the & operator, and dereferencing (the * operator)
x vs. &x vs. *x
 
 
** Motivation
 

#+begin_src c++
int *x, *y, p, q; // vs. int* x, y, p ,q; 
 
    p = 5; 
    q = 6;
 
    x = &p;
    y = &q;
 
    if(x==y){
    cout << Yeah, and I am Cinderella!;
    cout << n; 
    }
    x = y;   
cout << *x << n;
 
    x = &p;
cout << *x << n;
 
*x = *y;
cout << *x << n;
cout << *&*x << n; 
#+end_src

cout << **&x << n;
 
** Recall value passing semantics
 
 - Call by value (arguments evaluated)
 

#+begin_src c++
    void doubleV(int a){
  a = a*2;
    }
 
    int main( ){
      int a = 2;
      doubleV(a+a);
      cout << a << endl;
 
      return 0;
    }
#+end_src

 - Call by reference (can only send vars)
 

#+begin_src c++
    void doubleR(int &a){
  a = a*2;
    }
 
    int main() {
      int a = 4;
      doubleR(a);
      cout << a << endl;
 
      return 0;
    }
 
 
#+end_src

** Recall value passing semantics
 
 - Call by address (arguments evaluated)
 

#+begin_src c++
void doubleP(int *a){
  *a = (*a)*2;
    }
 
    int main( ){
      int a = 4;
      doubleP(&a);
      cout << a << endl;
 
      return 0;
    }
#+end_src

 - Call by reference (can only send vars)
 

#+begin_src c++
    void doubleR(int &a){
  a = a*2;
    }
 
    int main() {
      int a = 4;
      doubleR(a);
      cout << a << endl;
 
      return 0;
    }
 
 
#+end_src

** Another example
 
 - Call by address (arguments evaluated)
 

#+begin_src c++
void swap(int *a, int *b){
int temp = *a;
   *a = *b;
   *b = temp;
    }
 
    int main( ){
      int a = 4, b = 6;
      swap(&a, &b);
      cout << a << endl;
      return 0;
    }
#+end_src

 - Call by reference (can only send vars)
 

#+begin_src c++
    void doubleR(int &a, int &b){
      int temp = a;
      a = b;
      b = temp;
    }
 
    int main() {
      int a = 4, b = 6;
      swap(a, b);
      cout << a << endl;
      return 0;
    }
 
#+end_src

** Constant pointers 
 

#+begin_src c++
    struct BigRecord {
    ...
    };
 
void f(const BigRecord *pRec1){
    ...
    BigRecord pRec2;
    ...
*pRec1 = *pRec2; // Wrong!
    pRec1 = pRec2;   // No issues 
    }
 
    int main(){
    BigRecord x;
    ...
    f(&x);
    ...
    }
 
    // but f( ) can change pRec1!
 
// vs. BigRecord const *pRec1
 
#+end_src

** Arrays and pointers
 

#+begin_src c++
    // Every array variable can be used as 
    // a pointer to the first member of the 
    // array (with certain restrictions)
 
    // Array argument
 
    int sumArray(int A[], unsigned int n){   
    int sum = 0;
    for (int i = 0; i < n; i++){
    sum += A[i];
    }
    return sum;
    }
    // This is why arrays are (by default)
    // passed by references
 
 
    // Array as pointer
 
int sumArray(int *A, unsigned int n){  
    int sum = 0;
    for (int i = 0; i < n; i++){
sum += A[i]; // or, *(A+i)
    }
    return sum;
    }
 
#+end_src

** Arrays and pointers
 

#+begin_src c++
    int A[5] = {1, 5, 10, 15, 20};
 
    cout << A[0];
cout << *(A+0);
cout << *A;
 
cout << *(A+3);
cout << *A+3; 
cout << *(A+3)+3;
 
 
 
    A++; // Wrong!
 
    // But this works!
int *B = A; // or int *B = &(A[0]);
    B++; // line 11 (see below)
cout << *B;
 
    // compiler automatically increments 
    // it to the proper location depending 
    // on the type of data B is pointing to, 
    // e.g. multiples of 4 for int/float and 8 
    // for double, etc.
 
 
#+end_src

** C-strings and pointers
 

#+begin_src c++
    // computing the length of string #1
 
    unsigned int cstringLength(const char s[]) {
    unsigned int length = 0;
#+end_src

 - while (s[length] != 0)

#+begin_src c++
    length++;
    return length;
    }
 
 
 
 
 
    // computing the length of string #2
 
unsigned int cstringLength(const char *s) {
    unsigned int length = 0;
#+end_src

while (*(s + length) != 0)

#+begin_src c++
    length++;
    return length;
    }
 
 
#+end_src

 

#+begin_src c++
    // computing the length of string #3
    // how it is actually implemented!
 
unsigned int cstringLength(const char *s) {
const char *p = s;
#+end_src

while (*p != 0)

#+begin_src c++
    p++;     
    return p - s; // pointer difference
    }
 
#+end_src

 - In general, given two pointers p and q of the same type, (p - q) is the integer that can be added to p to obtain q.
 
 

#+begin_src c++
    // string copy using c-string
 
    void cstringCopy(char des[], const char src[]){
    for (unsigned int int i = 0; src[i] != 0; i++)
    des[i] = src[i];
    des[i] = 0;
    }
 
 
#+end_src

 

#+begin_src c++
    // string concatenation
    void cstringConcat(char des[], const char src[]){
    unsigned int i;
    // find the end of the destination c-string des
    for (i = 0; des[i] != 0; i++)
    ; // do nothing
    // append the source c-string src to the end of des
    for (unsigned int j = 0; src[j] != 0; j++){
    des[i] = src[j];
    i++;
    }
    // add a c-string terminator to the end of des
    des[i] = 0;
    }
 
 
#+end_src

** Programming using pointers
 

#+begin_src c++
    // Book record
    struct Book {
    string title;
    string author;
    string call_number;
    };
 
    // Global Book collection
#+end_src

 - Book collection[] = 

#+begin_src c++
    { 
    { "Computer Security: Art and Science", "Matt Bishop", "QA 76.9.A25 B56 2002" },
    	{ "Applied Cryptography", "Bruce Schneier","QA 76.9.A25 S35 1996"},
    	{ "Practical Software Maintenance", "Thomas M. Pigoski","QA 76.76.S64 P54 1996"}
    };
 
#+end_src

** Programming using pointers
 

#+begin_src c++
    // function for printing Books
    void printBook(const Book &book){
    cout << "title: " << book.title << endl;
    cout << "author: " << book.author << endl;
    cout << "call number: " << book.call_number << endl;
    }
 
    // function for finding a Book with some title
    unsigned int findBook(const Book collection[], unsigned int n, const string &title){
    for (unsigned int i = 0; i < n; i++){
    if (collection[i].title == title)
    return i;
    }
    return n;
    }
 
#+end_src

** Programming using pointers
 

#+begin_src c++
    const unsigned int COLLECTION_SIZE = sizeof(collection) / sizeof(Book);
 
    int main(){
    unsigned int i = findBook(collection, COLLECTION_SIZE, "Applied Cryptography");
    if (i == COLLECTION_SIZE)
    cout << "Book not found" << endl;
    else
    printBook(collection[i]);
    return 0;
    }
 
 
#+end_src

** Programming using pointers
 

#+begin_src c++
    // function for printing Books
    void printBook(const Book &book){
    cout << "title: " << book.title << endl;
    cout << "author: " << book.author << endl;
    cout << "call number: " << book.call_number << endl;
    }
 
void printBook(const Book *book){
    cout << "title: " << book->title << endl;
    cout << "author: " << book->author << endl;
    cout << "call number: " << book->call_number << endl;
    }
 
#+end_src

** Programming using pointers
 

#+begin_src c++
    // function for finding a Book with some title
    unsigned int findBook(const Book collection[], unsigned int n, const string &title){
    for (unsigned int i = 0; i < n; i++){
    if (collection[i].title == title)
    return i;
    }
    return n;
    }
const Book *findBook(const Book collection[], unsigned int n, const string &title){
for (const Book *p = collection; p < collection + n; p++){
    if (p->title == title)
          return p;
    }
    return nullptr;
    }
 
#+end_src

** Programming using pointers
 

#+begin_src c++
    const unsigned int COLLECTION_SIZE = sizeof(collection) / sizeof(Book);
 
    int main(){
const Book *b = findBook(collection, COLLECTION_SIZE, "Applied Cryptography");
    if (b == nullptr)
    cout << "Book not found" << endl;
    else
    printBook(b);
    return 0;
    }
 
 
#+end_src

* Dynamic memory management
 - using pointers
 
 
 
 
** Motivation
 
 - So far used pointers for allocating space during compile-time only
 - error-prone and might be difficult to understand 
 - could have avoided by using arrays and references 
 
 - we can allocate memory of size MAX (a constant)
 
 - Problems with this model:
 - might run out of space (despite having a lot of unused memory)
 - can be under-utilized (e.g. if we only use a small part of MAX)
 
 - Solution: allocate memory on demand at run-time!
 
 
 
 
** Motivation
 
 - Allocates memory in ``heap (in contrast to .text, .data, and stack)
 
 - Uses keyword new to allocate memory

#+begin_src c++
int *px = new int;
*px = 777;
cout << *px;
 
    Must free-up space when done, using keyword delete (otherwise memory leak can happen!); also clean up any dangling pointers using nullptr
    ...
    delete px;
    px = nullptr;
 
#+end_src

** Simple example
 

#+begin_src c++
    struct Book {
    string title;
    string author;
    string call_number;
    };
 
void printBook(const Book *pBook){
    cout << "title: " << pBook->title << endl;
    cout << "author: " << pBook->author << endl;
    cout << "call number: " << pBook->call_number;
    cout << endl;
    }
 
 
    int main(){
    // allocate a Book from heap
Book *pb = new Book; 
 
    pb->title = "Security";
    pb->author = "Matt Bishop";
    pb->call_number = QA.420;
 
    printBook(pb);
 
    delete pb; // explicit deallocation           
 
    return 0;
    }
 
 
#+end_src

** Pictorial representation
 

#+begin_src c++
Book *p;
    p = new Book;
    p -> title = "Emma";
 
 
#+end_src

** Array of pointers
 

#+begin_src c++
Book *pb[10];
 
 
 
 
 
 
 
 
 
 
 
    for (int i = 0; i < 10; I++){
    pb[i] = new Book;
    pb[i] -> title = "Emma";
    }
 
 
#+end_src

** Array of pointers
 

#+begin_src c++
    for (int i = 0; i < 10; i++)
    delete pb[i];
 
 
 
 
 
 
 
 
 
 
#+end_src

 - Dangling pointers!
 - assign nullptr to indicate this
 

#+begin_src c++
    for (int i = 0; i < 10; i++)
    pb[i] = nullptr;
 
 
 
#+end_src

** Pointer to dynamic array
 

#+begin_src c++
Book *parray = new Book[10];
 
 
 
 
 
 
 
 
 
 
    for (int i = 0; i < 10; i++)
 
    // could have also used:
 
    // (parray+i)->title = "Emma";
 
// (*(parray+i)).title = "Emma";
 
 
#+end_src

** Pointer to dynamic array
 

#+begin_src c++
Book *parray = new Book[10];
 
    for (int i = 0; i < 10; i++)
    parray[i].title = "Emma";
 
    ...
 
    delete [ ] parray;
 
    parray = nullptr;
 
 
 
#+end_src

** Pointer to array of pointers (double pointer)
 
Book **pparray = new Book * [10];
 
 
 
 
 
 
 
 
 
 
 

#+begin_src c++
    for (int i = 0; i < 10; i++){
    parray[i] = new Book;
    parray[i] -> title = "Emma";
    }
 
 
#+end_src

** Pointer to array of pointers (double pointer)
 
Book **pparray = new Book * [10];
 

#+begin_src c++
    for (int i = 0; i < 10; i++){
    pparray[i] = new Book;
    pparray[i] -> title = "Emma";
    }
 
#+end_src

 - Deallocation must be done in the reverse order of allocation
 
 
 

#+begin_src c++
    for (int i = 0; i < 10; i++){
    delete pparray[i];
    // following is redundant, since we 
    // are about to delete parray
    pparray[i] = nullptr; 
    }
    delete [] pparray;
    pparray = nullptr;
 
 
 
#+end_src

** Collection data structures with maximum capacity
 

#+begin_src c++
    const int CAPACITY = 1000;
 
    int main(){
    int A[CAPACITY];
    int length;
 
    cin >> length;
 
    for (int i = 0; i < length; i++)
    cin >> A[i];
 
 
    for (int i = length - 1; i >= 0; i--)
    cout << A[i] << endl;
 
    return 0;
    }
 
 
#+end_src

** Collection data structures w/o maximum capacity
 

#+begin_src c++
    int main(){
    int length;
int *A;
 
    // Read length of sequence
      cin >> length;
 
    // Allocate enough memory to hold 
    // sequence
    A = new int[length];
 
 
    for (int i = 0; i < length; i++)
    cin >> A[i];
 
    // Write sequence in rev. order
    for (int i = length - 1; i >= 0; i--)
    cout << A[i] << endl;
 
    // Deallocate memory
    delete [] A;
 
    return 0;
    }
 
 
#+end_src

** Collection data structures that dynamically expand/shrink
 
 - Initialize the array with some arbitrary capacity
 
 - Insert integers into the array as usual
 
 - When the array is filled up, expand the capacity of the array as follows:
 - allocate a bigger array
 - copy the contents of the old array to the new one
 - deallocate the old array
 - use the new array to store incoming integers until it is filled up again
 
 - Deallocate the array when it is no longer needed
 
** Collection data structures that dynamically expand/shrink
 

#+begin_src c++
    int main(){
    // Initialize encapsulated array
    init();
 
    // Read sequence
    int x;
    cin >> x;
    while (cin){
    append(x);
    cin >> x;
    }
 
      // Write sequence in reverse order
      for (unsigned int i = length(); i > 0; i--)
      cout << retrieve(i - 1) << endl;
 
      // Deallocate encapsulated array
      cleanup();
 
      return 0;
    }
 
 
#+end_src

** Collection data structures that dynamically expand/shrink
 

#+begin_src c++
    // Amount of memory available
    unsigned int array_capacity = 0;   
 
    // Amount of memory used
    unsigned int array_length = 0;     
 
    // Actual memory resource
int *array = nullptr;             
 
    bool isInitialized(){
    return (array != nullptr);
    }
 
    void init(){
    assert(! isInitialized());
 
    // Default initial capacity
    array_capacity = 4;
 
    // Array is empty initially
    array_length = 0;                    
    // Allocate array
    array = new int[array_capacity];    
 
    assert(isInitialized());
    } // end init()
 
 
 
#+end_src

** Collection data structures that dynamically expand/shrink
 

#+begin_src c++
    void append(int x) {
    assert(isInitialized());
 
    // Expand capacity if full
    if (array_length == array_capacity)  
      expand();
 
    // Append to the end  
    array[array_length] = x;              
    // Update array length
    array_length++;                      
    } 
 
 
#+end_src

** Collection data structures that dynamically expand/shrink
 

#+begin_src c++
    void expand(){
    assert(isInitialized());
    assert(array_capacity > 0);
    assert(array_length == array_capacity);
 
    // Calculate new capacity
int new_array_capacity = array_capacity*2;       
    // Allocate bigger array
#+end_src

int *new_array = 

#+begin_src c++
                new int[new_array_capacity];   
 
    // Copy contents
    for (unsigned int i = 0; i < array_length; i++) 
    new_array[i] = array[i];
    // Deallocate old array
    delete [] array;                                 
 
    // Use new array and update capacity
    array = new_array;                              
    array_capacity = new_array_capacity;             
 
    assert(array_length < array_capacity);
    }
 
 
#+end_src

** Collection data structures that dynamically expand/shrink
 

#+begin_src c++
    unsigned int length(){
    assert(isInitialized());
    return array_length;
    }
 
 
    int retrieve(unsigned int i){
    assert(isInitialized());
    assert(i < length());
 
    return array[i];
    }
 
    void cleanup(){
    assert(isInitialized());
 
    // Deallocate memory resource
    delete [] array;                      
    // Establish postconditions
    array = nullptr;                      
 
    array_capacity = 0;
    array_length = 0;
 
    assert(! isInitialized());
    }
 
#+end_src

** Dynamically allocated 2d arrays
 

#+begin_src c++
    // allocate the 2D array
#+end_src

int** pparray;
 
 
 
 
 

#+begin_src c++
    pparray = nullptr;
 
 
 
 
 
pparray = new int*[10];
 
 
 
 
 
 
 
#+end_src

** Dynamically allocated 2d arrays
 

#+begin_src c++
    // allocate the 2D array
#+end_src

int** pparray = nullptr;

#+begin_src c++
pparray = new int*[10];
 
    for (unsigned int i = 0; i < 10; i++){
    pparray[i] = new int[20];
    }
 
 
 
 
 
 
#+end_src

** Dynamically allocated 2d arrays
 

#+begin_src c++
    // store 7 in position 6 of row 2
    pparray[2][6] = 7;
 
#+end_src

 - How about using pointers?
 

#+begin_src c++
    // when done:
    // deallocate in reverse order
    for (unsigned int i = 0; i < 10; i++)
    delete [] pparray[i];
    delete [] pparray;
 
 
 
 
 
 
 
#+end_src

** Dynamic memory management and ADTs
 
 - Why handle manually when we can automate allocation using constructors and deallocation using destructors?
 
 - design a wrapper class for c-strings for 
   + allocating and deallocating memory for c-strings 
   + streamline the copying and concatenation of c-strings 
 
 
 
 
 
 
 

#+begin_src c++
    class String {
    public:
    ...  
    unsigned int length() const;
    char member(unsigned int i) const;
    ...
    private:
const char *buf;
    };
 
 
 
 
    unsigned int String::length() const {
    return strlen(buf);
    }
 
    char String::member(unsigned int i) const {
    assert(i < length());
 
    return buf[i];
    }
 
 
#+end_src

 

#+begin_src c++
    class String {
    public:
String(const char *s);
 
    unsigned int length() const;
    char member(unsigned int i) const;
 
    private:
const char *buf;
    };
 
    // Usage: String s("Hello World");
    // Alternate syntax: String s = "Hello World";
    // implementation
 
String::String(const char *s) {
#+end_src

char *newbuf 

#+begin_src c++
    = new char[strlen(s) + 1];
    strcpy(newbuf, s);
    buf = newbuf;
    }
 
 
#+end_src

 

#+begin_src c++
    class String {
    public:
String(const char *s);
    ~String();     // Destructor prototype
 
    unsigned int length() const;
    char member(unsigned int i) const;
 
    private:
const char *buf;
    };
 
 
    // Usage
 
    { // begin of scope
    ...
    } // end of scope: memory should be 
      // reclaimed here
 
    // Implementation 
 
    String::~String() {
    delete [] buf;
    }
 
 
#+end_src

 

#+begin_src c++
    class String {
    public:
    String();        // Default constructor
String(const char *s);
    ~String();     // Destructor prototype
 
    unsigned int length() const;
    char member(unsigned int i) const;
 
    private:
const char *buf;
    };
 
 
    // Implementation 
 
    String::String(){
    // Create a c-string of length 0
char *newbuf = new char[1]; 
    newbuf[0] = 0;
    buf = newbuf;
    }
 
 
#+end_src

 

#+begin_src c++
    class String {
    public:
    String();
String(const char *s);
    String(const String &original); 
    ~String();
 
    unsigned int length() const;
    char member(unsigned int i) const;
 
    private:
  const char *buf;
    };
    // deep copying intended
 
    String::String(const String &original) {
    unsigned int len = original.length();
#+end_src

char* nonConstBuf 

#+begin_src c++
    = new char[len + 1];
    strcpy(nonConstBuf, original.buf);
    buf = nonConstBuf;
    }
 
    // is the & before original really required?
 
#+end_src

 
 - Three different uses:
 

#+begin_src c++
    // for initializing a string object by another
    String s("Hello"); // Const. invoked
    String t(s);           // Copy const. invoked
 
    // Alternative syntax
    String s = "Hello"; // Const. invoked
    String t = s;           // Copy const. invoked
 
    // for passing String args. by value
    void f(String s){
      ...
    }
    ...
    String t = "Hello";
    f(t);    // Copy const. invoked
 
    // for returning string instances as value
    String f(...){
    String s;
    ...
    // Copy const. invoked to create 
    // return value
    return s;    
    }
 
 
 
 
 
#+end_src

 
 - Can the & before &original be left out?
 

#+begin_src c++
    String::String(const String &original) {
    unsigned int len = original.length();
char *nonConstBuf = new char[len + 1];
    strcpy(nonConstBuf, original.buf);
    buf = nonConstBuf;
    }
 
#+end_src

 - No: The copy constructor is always invoked whenever an argument of the type is passed by value to any function
 - so if & is left out, it will repeatedly call the copy constructor till the stack overflows!   
 
 
 
 

#+begin_src c++
    class String {
    public:
    String &operator=(const String &original);  // Assignment operator
    ...                                                        // try (a=b)=c with a cons String & return type!
    private:
  const char *buf;
    };  
 
    String s;                 // default constructor
    String t = "Hello";  // auxiliary constructor
    String u(t);             // copy constructor
    s = u;                    // assignment operator
 
#+end_src

 

#+begin_src c++
    String &String::operator=(const String &original) {
    unsigned int len = original.length(); // len is length of string to be copied
char *nonConstBuf = new char[len + 1]; // allocate new space of size len
    strcpy(nonConstBuf, original.buf); // copy original string to new space (Line 4)
    delete [] buf; // deallocate old string (Line 5)
    buf = nonConstBuf; // make old string pointer point to newly allocated space
 
return *this;
    }
 
    // a potential issue
    String s = "Hello, World";
    s = s;   // Self assignment! Q: Is there anything wrong with this? 
    // Ans. might do extra work; even more problematic if Line 5 is moved before Line 4
 
 
#+end_src

 

#+begin_src c++
    String &String::operator=(const String &original) {
    if (&original != this){
    unsigned int len = original.length(); // len is length of string to be copied
char *nonConstBuf = new char[len + 1]; // allocate new space of size len
    strcpy(nonConstBuf, original.buf); // copy original string to new space
    delete [] buf; // deallocate old string
    buf = nonConstBuf; // make old string pointer point to newly allocated space
    }
 
return *this;
    }
 
 
 
#+end_src

** Concatenation
 

#+begin_src c++
    class String {
    public:
    ...
    String &append(const String &s);
    ...
    private:
const char *buf;
    };
 
    // note: none of the following work
    // void append(const String &s) 
    //  String append(const String &s)
 
    String s = "Hello";
    String t = " World";
    s.append(t);            // "Hello World"
 
    String s = "Hello";
    String t = " ";
    String u = "World";
    s.append(t).append(u);
 
 
#+end_src

** 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 - Allocate a buffer that is big enough to hold both the content of the current object and that of the argument
 
 - Copy the content of the current object to the beginning of the buffer
 
 - Append the content of the argument to the end of the buffer
 
 - Delete the original content of the current object
 
 - Install the buffer into the current object
 
 
** Concatenation
 

#+begin_src c++
    String &String::append(const String &s){
    unsigned int len = strlen(buf) + strlen(s.buf);
char *newbuf = new char[len + 1];
    strcpy(newbuf, buf);
    strcat(newbuf, s.buf);
    delete [] buf;
    buf = newbuf;
 
return *this;
    }
 
 
#+end_src

** Concatenation
 
 

#+begin_src c++
    String concatenate(const String &s) const; // prototype
 
    // usage
    String s = "Hello";
    String t = " World";
    String u = s.concatenate(t);
 
    // implementation
    String String::concatenate(const String &s) const {
return String(*this).append(s);
    }
 
 
#+end_src

** Concatenation
 
 - Efficient only if supported by the compiler
 

#+begin_src c++
String::String(const char *s, const char *t) {
    unsigned int len = strlen(s) + strlen(t);
char *newbuf = new char[len + 1];
    strcpy(newbuf, s);
    strcat(newbuf, t);
    buf = newbuf;
    }
 
    String String::concatenate(const String &s) const {
    return String(buf, s.buf); // still calls the copy constructor, but some smart compilers
    }                                            // will be able to recognize and avoid this unnecessary task
 
#+end_src

* Dynamic memory management
 - and object-oriented design
 
 
 
 - Interaction between dynamic memory management and OOD features, such as composition, inheritance, and dynamic binding
 
** Composition and inheritance
 
 - Recall invocation seq. of const.
 

#+begin_src c++
    class C : ... { 
    ... 
    };
#+end_src

 - Invocation sequence does not depend on the order in which constructors are called, but as follows:
 - const. of base class
 - const. of member vars, in the order they are defined
 - body of the constructor 

#+begin_src c++
    class D : public C {
    public:
    D(...);
    ...
    private:
    D1 f1;
    D2 f2;
    ...
    };
 
    D::D(...) : C(...), f2(...), f1(...), ... {
      ... // body
    }
 
#+end_src

** Constructor invocation sequence example
 

#+begin_src c++
    class C {
    public:
    C();
C(const char *s);
    };
    C::C() {
    cout << "C()" << endl;  
    }
C::C(const char *s) {
cout << "C(const char *)" << endl;  
    }
    class D : public C {
    public:
    D();
    };
 
 
    D::D() : C() {
    cout << "D()" << endl;  
    }
    class E : public D {
    public:
    E();
    private:
    C x;
    C z;
    };
    E::E() : D(), x("Hello"), z("Goodbye"){
    cout << "E()" << endl;  
    }
    int main() {
        E y;
        return 0;
    }
 
#+end_src

** Destructor invocation sequence
 
 - Destructor invocation sequence is exactly the opposite of that of the constructor!
 

#+begin_src c++
    class C : ... { 
    ... 
    };
 
#+end_src

 - When an object of type D goes out of scope, ~D() is called, which executes its body, then calls ~C2(), then ~C1(), and finally ~C() 
 
 
 

#+begin_src c++
    class D : public C {
    public:
    ...
    ~D();
    private:
    C1 f1;
    C2 f2;
    ...
    };
 
    D::~D() {
    ... // body of ~D()
    }
 
 
#+end_src

 

#+begin_src c++
    class C{
    public:
    ~C() { cout << "~C()" << endl; }
    };
 
    class C1 : public C {
    public:
    ~C1() { cout << "~C1()" << endl; }
    };
 
    class C2 : public C {
    public:
    ~C2() { cout << "~C2()" << endl; }
    };
 
    class D : public C {
    public:
    ~D() { cout << "~D()" << endl; }
    private:
    C1 x;
    C2 y;
    };
 
    int main() {
    D z;
    return 0;
    }
 
 
#+end_src

** Constructors and destructors
 

#+begin_src c++
String *ps = new String; // calls constructor as usual
 
 
    delete ps; // (explicitly) calls the destructor
 
 
#+end_src

** Recall: static vs. dynamic binding
 

#+begin_src c++
    class C {
    public:
virtual void f() { /* implementation 1 */ }
    ...
    };
 
    class D : public C {
    public:
    // implictly virtual
void f() { /* implementation 2 */ }
    ...
    };
 
 
 
    void g(C &c) {
    c.f( );
    }
 
    int main() {
    D d;
    d.f();  // static binding: impl.2 invoked 
    g(d);  // dynamic binding: impl.2 
             // invoked 
    return 0;
    }
 
 
#+end_src

** Virtual destructor
 

#+begin_src c++
    class C {
    public:
    // Say this is an abstract class
    ... 
    ~C();		// WRONG, use virtual ~C() instead 
    };
 
    class D : public C {
    public:
    ... 
    ~D();
    private:
    ... 
    };
void destroy(C *ptr) {
    ... 
    delete ptr; // wanted to call ~D()
    ...
    }
 
    int main() {
C *p = new D;
    destroy(p);
    return 0;
    }
 
#+end_src

** Using classes that involve dynamically allocated memory
 
 - If you craft your class properly by equipping it with: 
 - a default constructor 
   + a copy constructor 
 - an assignment operator and 
 - a destructor 
 - then you may simply treat the class as a built-in type
 
** Example (using String to define Book)
 

#+begin_src c++
    class Book {
    public:
    Book(const String &a, const String &t);
    Book(const Book &b);
    ~Book();
    Book &operator=(const Book &b);
    ... 
    private:
    String author;
    String title;
    };
 
#+end_src

 - Book::Book(const String &a, 

#+begin_src c++
    const String &t) : author(a), title(t) { }
    Book::Book(const Book &b) : author(b.author), title(b.title) { }
 
    Book &operator=(const Book &b){
    if (&b != this){
    author = b.author;
    title = b.title;
    }
return *this;
    }
 
    Book::~Book() { }
 
#+end_src

** Polymorphism
 
 - Base class pointer = child class instance : works as expected
 - Child class pointer = base class instance : WRONG
 

#+begin_src c++
    class Critter { 
    ... 
    };
 
    class Spider : public Critter {
    ...
    };
 
Critter *cp = new Spider(...); // works
Spider *sp1 = new Critter(...); // WRONG!
Spider *sp2;	
    sp2 = cp; // WRONG!
 
 
#+end_src

** Polymorphism with pure virtual functions
 

#+begin_src c++
    class Critter { 
    private:
    int legCount;
    public:
    Critter(int n);
    virtual void print() = 0;
    };
 
    Critter::Critter(int n){
    legCount = n;
    }
 
    // Note: there is no implementation for the 
    // pure virtual function named print
 
 
    class Spider:  public Critter{ 
    private:
    bool poisonous;
    public:
    Spider(bool poisonous1);
    virtual void print();
    };
 
    void Spider::print(){
    // body implements virtual func.
    }
 
Spider *sp = new Spider(true);
    sp->print();
Critter *cp = sp;
    cp->print(); // dynamic binding
 
#+end_src

** Polymorphism and dynamic arrays
 

#+begin_src c++
Critter *critter_array[100];
    for (int i = 0; i < 100; i++) {
    		if (i % 2 == 0)
    		critter_array[i] = new Spider(false);
    		else
    		critter_array[i] = new Ant(6, 50);
    	}
 
 
 
 
 
 
#+end_src

Critter **critter_array = new Critter*[100];

#+begin_src c++
    for (int i = 0; i < 100; i++) {
    		if (i % 2 == 0)
    		critter_array[i] = new Spider(false);
    		else
    		critter_array[i] = new Ant(6, 50);
    	}
 
 
#+end_src

* Canonical forms for C++ classes
 
 
 
 
** Canonical form (definition)
 
 - A C++ class is in canonical form if it provides the following four member functions/operators:
 - default constructor
 - copy constructor
 - destructor
 - assignment operator
 
 - These are otherwise provided by default
 - unless some constructor other than the copy constructor is provided for a class, then the default constructor is not provided by default!
 
 - The reason for putting a class in canonical form: to avoid memory leaks and to make call by value and return from functions work as expected
 
 
 
** How to write a copy constructor
 
 - MyClass::MyClass(const MyClass &original)

#+begin_src c++
         : MyBaseClass(original), // delegate copying of base class fields to its own cc
           field1(original.field1),    // delegate copying of field1 to its own cc, etc.  
#+end_src

 -        field2(original.field2),
 -        field3(original.field3)

#+begin_src c++
           // ...
    {
 
    // do everything that is required to perform a deep copy of original fields to the 
    // reference object fields
 
    }
 
 
#+end_src

** How to write a destructor
 
 - MyClass::~MyClass()

#+begin_src c++
    {
    // usually empty (unless code performed dynamic allocation)
 
    // free/deallocate all dynamically allocated memory in the reverse order of their 
    // allocation order
    }
 
#+end_src

 - A virtual destructor should be used for any class that is involved in inheritance, i.e., for any base class or any derived class (see week 10 slide 46)
 - if in doubt, make it virtual

#+begin_src c++
    virtual ~MyClass();
#+end_src

 - never make it purely virtual, however (provide implementation regardless)
 
** How to write an assignment operator
 

#+begin_src c++
    MyClass &MyClass::operator=(const MyClass &original){
         {
               // 1. everything in destructor (to get rid of the existing value of this reference instance)
               // 2a. if this is a derived class, add this line
               MyBaseClass::operator=(original);
 
               // 2b. if the copy constructor copies fields using the ":" syntax (i.e., an initializer list), 
               // add these lines
               field1 = original.field1;
               field2 = original.field2;
               field3 = original.field3;
 
               // 2c. everything in copy constructor body
         } 
     return *this;
    }
 
 
#+end_src

** Example: the Committee class
 

#+begin_src c++
    class Committee { // a class with dynamic allocation
       private:
     float *pbudget;
     string *pmembers[10];
 
       public:
         // Default Constructor
         Committee();
 
         // Copy Constructor
         Committee(const Committee &original);
 
         // Destructor
         ~Committee();
 
         // Assignment Operator
         Committee &operator=(const Committee &original);
    };
 
#+end_src

** The Committee class (default constructor)
 

#+begin_src c++
    // Default Constructor
 
    Committee::Committee() {
 
         pbudget = new float(0.0f);
 
         for (int i = 0; i < 10; i++) {
               pmembers[i] = new string;
         }
 
    }
 
 
#+end_src

** The Committee class (copy constructor)
 

#+begin_src c++
    // Copy Constructor
#+end_src

 - Committee::Committee(const Committee &original)

#+begin_src c++
     :  pbudget(new float(*(original.pbudget))) // put this line (delegate copying to cc of float)
    {
         // OR these 2 lines (i.e. copy manually)
         // pbudget = new float;                     
     // *pbudget = *(original.pbudget);
 
         // OR this one line (again, copy manually)
     // pbudget = new float(*(original.pbudget)); 
 
         for (int i = 0; i < 10; i++) {
           pmembers[i] = new string(*(original.pmembers[i]));
         }
    }
 
 
#+end_src

** The Committee class (destructor)
 

#+begin_src c++
    // Destructor
#+end_src

 - Committee::~Committee()

#+begin_src c++
    {
         // optional for tracing execution:
         // cout << "Destructor for Committee class" << endl;
 
         delete pbudget;
         for (int i = 0; i < 10; i++)
         {
               delete pmembers[i];
 
               // optional for tracing execution:
               // cout << "Deleting array... " << 10 - i << endl;
         }
    }
 
#+end_src

** The Committee class (assignment operator)
 

#+begin_src c++
    Committee &Committee::operator=(const Committee &original) {
         if (&original != this) {
               // from destructor
               delete pbudget;
               for (int i = 0; i < 10; i++)
                    delete pmembers[i];
 
               // no base class from which to call operator
 
               // from copy constructor
           pbudget = new float(*(original.pbudget));
               for (int i = 0; i < 10; i++)
                pmembers[i] = new string(*(original.pmembers[i]));
         }
     return *this;
    }
 
 
#+end_src

** New C++ features to support canonical classes
 

#+begin_src c++
    Class A {
         A() = default; // default constructor has default implementation (i.e. does nothing)
         A(const A &original) = default; // copy const. has default impl. (i.e. shallow copies)
         ~A() = default; // destructor has default implementation (i.e. does nothing)
         A &operator=(const A &other) = default; // shallow copy again
         ...
    };
 
    // tells compiler that no implementation is desired (rarely a good idea)
    Class B{
         B() = delete; // e.g., prevents arrays from being declared
         B(const B &original) = delete; // prevent instances from being passed by value
         ...
    };
 
 
#+end_src

* Linked lists
 
 
 
 - A bare-bones version
 
** Motivation
 
 - Want to allocate memory on demand, but only 1 node at a time 
 - Idea: dynamically allocate only a single node when requested
 - problem: but then we will need an arbitrary number of static (i.e. allocated at compile-time) pointers to handle these Ñ back to square one!
 - one solution: why not use just 1 static pointer to dynamically allocate the first node, but rather than allocating just for the data, allocate enough space for a compound node structure consisting of the data as well as a pointer to some potential next node 
 - if the next node does not exist, indicate this by assigning the pointer to null pointer
 - This allows us to gradually develop a linked data structure that can dynamically grow and shrink as needed
 
 
 
** Node definition
 

#+begin_src c++
    struct Node{
    int data;       // the actual data
Node *next; // pointer to potential next node
    };
 
    // We only need 1 pointer to handle this linked list
    // It points to the first node of the list
 
    // Initially, there are no nodes, i.e. the list is empty
 
    head = nullptr;
 
#+end_src

** Adding a new node to the list
 

#+begin_src c++
    void insert(int data){
 
Node *temp = head;
 
    if(temp == nullptr){
    temp = new Node;
    temp->data = data;
    temp->next = nullptr;
    head = temp;
      }  
 
 
 
    else{
#+end_src

 - while(temp->next != nullptr)

#+begin_src c++
    temp = temp->next;
    temp->next = new Node;
    temp = temp->next;
    temp->data = data;
    temp->next = nullptr;
    }
 
    } // end insert
 
#+end_src

** Adding a new node to the list
 

#+begin_src c++
    void insertS(int data){
 
Node *curr = head;
Node *prev = nullptr;
 
    while(curr!=nullptr && curr->data<data){
    prev = curr;
    curr = curr->next;
    }
 
 
 
 
    if(prev == nullptr){
        prev = new Node;
        prev->data = data;
        prev->next = curr;
        head = prev;
    }
    else{  
        prev->next = new Node;
        prev = prev->next;
        prev->data = data;
        prev->next = curr;
        }  
    } // end insertS
 
#+end_src

** Traversing the list
 

#+begin_src c++
    bool isEmpty(){
    return head == nullptr;
    }
 
 
    void print(){
Node *temp = head;
    while(temp != nullptr){
    cout << temp->data <<" ";
    temp = temp->next;
    }
    }
 
 
    int count() {
Node *temp = head;
    int ctr=0;
    while(temp != nullptr){
    ctr++;
    temp = temp->next;
    }
    return ctr;
    }
 
#+end_src

** Deleting the entire list
 

#+begin_src c++
    void deleteLinkedList(){
 
Node *current = head, *previous = nullptr; 
 
    while(current != nullptr){
    previous = current;
    current = current->next;
    delete previous;
    }
 
    head = nullptr;
 
    }
 
#+end_src

** Removing a node
 

#+begin_src c++
    void remove(int x){
Node *prev = nullptr;
Node *curr = head;
 
    if(isEmpty())
    return;
    while(curr != nullptr){
    if(curr->data == x)
    break;
    else{
    prev = curr;
    curr = curr->next;
    }
    } // end while
    // found: 1st node needs removing
    if(prev == nullptr){
Node *temp = head;
    head = head->next;
    delete temp;
    }
 
    // found: curr needs removing
    if(curr != nullptr && prev != nullptr){
    prev->next = curr->next;
    delete curr;
    }
 
    } // end remove
 
#+end_src

** Testing it all out
 

#+begin_src c++
    int main() {
 
    insert(5);
    insert(6);
    insert(7);
 
    // try out every possibility
    remove(8); // 5, 7, empty list
 
    insert(3);
 
    print();
 
 
    deleteLinkedList();
 
 
    return 0;
    }
 
#+end_src

* Linked lists
 
 
 
 - An application: Multiset Revisited
 
** ADT Multiset
 
 - Domain: items from ItemType
 
 - Structure: arbitrarily many members, possibly with duplicates
 
 - Operations supported:
 - empty: check if a Multiset instance is empty.
 - memberCount: get the number of items in a Multiset instance
 - insert: insert an item of type ItemType into a Multiset instance
 - remove: remove the first occurrence of an item of type ItemType from a Multiset instance
 - member: test if an item of type ItemType is in a Multiset instance
 - print: print the members of a Multiset instance in ascending order
 
** ADT Multiset
 

#+begin_src c++
    // multiset-linkedlist.h
    typedef int ItemType;
    struct Node {
    	ItemType datum;
	Node *pNext;
    };
 
    class Multiset {
    public:
    // Default constructor
    Multiset();
    // Copy constructor
    Multiset(const Multiset &original);
    // Destructor
    ~Multiset();
    // Assignment operator
    Multiset &operator=(const Multiset &original);
    // Other functions
    bool empty() const;
    unsigned int memberCount() const;
    void insert(ItemType x);
    void remove(ItemType x);
    bool member(ItemType x) const;
    void print() const;
    private:
Node *pHead;
    }; // end Multiset
 
 
 
#+end_src

** Traversing and managing a linked list
 
 - Traversing: 
 

#+begin_src c++
    bool empty() const;
    unsigned int memberCount() const;
    void print() const;
 
#+end_src

 - Managing (both are private helper member functions):
 

#+begin_src c++
void deleteLL(Node *pHead) const;
Node *duplicateLinkedList(const Node *pOldHead) const;
 
#+end_src

** Implementing duplicateLL
 

#+begin_src c++
Node *duplicateLL(const Node *pHead1) const{
 
    // empty list
    if (pHead1 == nullptr)
    return nullptr;
 
    // handle the first node separately
Node *pHead2 = new Node;
    pHead2->data = pHead1->data;
 
    // Copy the rest of the linked list
const Node *p1 = pHead1;
Node           *p2 = pHead2;
 
 
 
      // still Nodes to copy
      while (p1->pNext != nullptr) {
    // make a new Node for our copy
    p2->pNext = new Node;
 
    // advance both linked lists
    p1 = p1->pNext;
    p2 = p2->pNext;
 
    // copy the data
    p2->data = p1->data;
      }
      // set the end of the new list to nullptr
      p2->pNext = nullptr;
 
      return pHead2;
    }
 
#+end_src

** Constructors and destructors
 

#+begin_src c++
    // default constructor
    Multiset::Multiset(){
    pHead = nullptr;
    }
 
    // copy constructor
    Multiset::Multiset(const Multiset &original){
    pHead = duplicateLL(original.pHead);
    }
 
    // destructor
    Multiset::~Multiset(){
    deleteLL(pHead);
    }
 
 
 
#+end_src

** Assignment operator
 

#+begin_src c++
    Multiset &Multiset::operator=(const Multiset &original){
    if (&original != this){
    deleteLL(pHead);
    pHead = duplicateLL(original.pHead);
    }
return *this;
    }
 
 
#+end_src

 
 - Membership checking, Inserting, and removing
 

#+begin_src c++
    bool Multiset::member(ItemType x) const; 
    void Multiset::insert(ItemType x); 
    void Multiset::remove(ItemType x); 
 
#+end_src

 - Helper function used in notes to implement insert, remove, and member
 - essentially returns ``prev
 

#+begin_src c++
Node *searchLinkedList(Node *pHead, ItemType x) const;
 
 
#+end_src

** Implementing member
 

#+begin_src c++
    bool Multiset::member(ItemType x) const {
 
Node *pPrev = searchLinkedList(pHead, x);
 
    if (pPrev != nullptr) // must be the next item, it at all
    return pPrev->pNext != nullptr && pPrev->pNext->data == x;
    else // must be the first item if even exists
    return pHead != nullptr && pHead->data == x;
 
    }
 
 
